{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"## Vectors\n\nA **vector** is an ordered finite list of numbers.\n\nA (column) vector x can be written as follow:\n\n$$ x = (4,7,6,3,2) = \\\\begin{bmatrix}4\\\\\\\\7\\\\\\\\6\\\\\\\\3\\\\\\\\2 \\\\end{bmatrix} $$\n\nNote that a row vector (say, `y`) can be written as *y* = (3 4 7 4 2) or\n$y = \\\\begin{bmatrix} 3&4&7&4&2\\\\end{bmatrix}$.\n\nYou can express the vector `x` above with the following R code:\n\n    x <- c(4,7,6,3,2)\n\nNotes:\n\nVectors (and matrices) are used a lot in equations, models, mathematical\noptimization problems. Learning how to read and use them allows you to\n(i) understand complex operations and (ii) express operations that you\nwant to perform in a compact and elegant way.\n\nA **vector** is an ordered finite list of numbers.\n\nIn R, vectors are one-dimension arrays that can hold numeric data,\ncharacter data or logical data. You can create a vector in R with the\ncombine function `c()`, where each element in the vector is separated by\na comma `,`.\n\n---\n\n## Vector Operations\n\n**Vector addition and subtraction**\n\nIf `a` and `b` are vectors of the same size, `a+b` and `a-b` give their\nsum and difference, respectively.\n\n    a <- c(1,2,3)\n    b <- c(100,200,300)\n    a+b\n\n    ## [1] 101 202 303\n\n    a-b\n\n    ## [1]  -99 -198 -297\n\n---\n\n**Scalar-vector multiplication and division**\n\nIf `c` is a number and `a` is a vector (from above), you can express the\nscalar-vector product either as `c*a` or `a*c`. For example, if you do\n`3*a` and `a*3`:\n\n    3*a\n\n    ## [1] 3 6 9\n\n    a*3\n\n    ## [1] 3 6 9\n\n---\n\n**Scalar-vector addition**\n\nIn R, you can add a scalar `c` and a vector `a` using c+a. This means\nthat the scalar is added to each element of the vector.\n\nFor example, if you do `3+a`:\n\n    3+a\n\n    ## [1] 4 5 6\n\nThis is, however, **NOT** a standard mathematical notation.\n\n(In mathematical notations, we should use this as, e.g. *a* + *c***1**,\nwhere *a* is a vector and *c* is a scalar.)\n\n---\n\n## Indexing and Slicing\n\n**Indexing**\n\nA specific element *x*<sub>*i*</sub> is selected with the expression\n`x[i]` where `i` is the index.\n\nSay, we would like to obtain the 5th entry from the following vector\n*x*:\n\n    x = c(5,6,3,4,5,8,23,4,6,4,3,23,7,5,4,23,7,90)\n    x[5]\n\n    ## [1] 5\n\nNotes:\n\nTo select elements of a vector (and later matrices, data frames, …), you\ncan use square brackets (`[ ]`). Between the square brackets, you\nindicate what elements to select. For example, consider a vector *x*, a\nspecific element *x*<sub>*i*</sub> is selected with the expression\n`x[i]` where `i` is the index (which runs from 1 to *n*, for a vector\nwith *n* elements).\n\n---\n\n**Slicing**\n\n*x*<sub>*r* : *s*</sub> denotes the slice of the vector from index *r*\nto *s*.\n\nFor instance, `x[1:4]` selects the element from index 1 to 4.\n\n    x[1:4]\n\n    ## [1] 5 6 3 4\n\nNotes:\n\nSometimes it is of interest to extract a slice of a vector (a\nsub-vector) using an index range as the argument.\n*x*<sub>*r* : *s*</sub> denotes the slice of the vector from index *r*\nto *s*.\n","fields":{"slug":"/chapter2_03_vectors"}}},{"node":{"rawMarkdownBody":"## Matrices\n\nA **matrix** is a rectangular array of numbers written between\nrectangular brackets (or large parentheses).\n\nFor example, matrix `A` is defined as follow:\n\n$$ A = \\\\begin{bmatrix}4&3&2\\\\\\\\7&4&2\\\\\\\\6&3&4\\\\\\\\3&0&0\\\\\\\\2&-2&-3 \\\\end{bmatrix} $$\nNote:\n\nMatrix `A` here is a 5 × 3 matrix (pronounced as `5 by 3`, indicating\nthere are 5 rows and 3 columns in the matrix).\n\n---\n\nYou can construct a matrix in R using the `matrix()` function.\n\nYou can express the matrix `A` on the previous slide with the following\nR code:\n\n    A <- matrix(c(4,3,2,7,4,2,6,3,4,3,0,0,2,-2,-3), byrow=TRUE, nrow=5)\n\nNote:\n\nIn R, a matrix is a collection of elements of the same data type\n(numeric, character, or logical) arranged into a fixed number of rows\nand columns.\n\nIn the R code shown on the slides:\n\n-   Here the first argument is the collection of elements that R will\n    arrange into the rows and columns of the matrix.\n\n-   The second argument `byrow` indicates the arrangement of elements is\n    done by filling the matrix by the rows. If you would like to fill\n    the matrix by columns, you can use `byrow=FALSE`.\n\n-   The third argument `nrow` indicates that the number of rows in the\n    matrix.\n\n---\n\n### Matrix Operations\n\nConsider the following operation:\n\n    A <- matrix(c(4,3,2,7,4,2,6,3,4,3,0,0,2,-2,-3), byrow=TRUE, nrow=5)\n    2*A\n\n    ##      [,1] [,2] [,3]\n    ## [1,]    8    6    4\n    ## [2,]   14    8    4\n    ## [3,]   12    6    8\n    ## [4,]    6    0    0\n    ## [5,]    4   -4   -6\n\n`2 * A` multiplies each element of `A` by two.\n\nNotes:\n\nSimilar to what you have learned with vectors, the standard operators\nlike `+`, `-`, `/`, `*`, etc. work in an element-wise way on matrices in\nR.\n\nFor example, `2 * A` multiplies each element of `A` by two.\n\n---\n\nConsider another matrix `B` defined as\n\n    B <- matrix(c(1,1,1,2,2,2,0,0,0,-1,-1,-1,0,0,0), byrow=TRUE, nrow=5)\n\n`A*B` creates a matrix where each element is the product of the\ncorresponding elements in matrix `A` and matrix `B`.\n\n    B <- matrix(c(1,1,1,2,2,2,0,0,0,-1,-1,-1,0,0,0), byrow=TRUE, nrow=5)\n    A*B\n\n    ##      [,1] [,2] [,3]\n    ## [1,]    4    3    2\n    ## [2,]   14    8    4\n    ## [3,]    0    0    0\n    ## [4,]   -3    0    0\n    ## [5,]    0    0    0\n\nNote:\n\nThose who are familiar with matrices should note that `A*B` creates a\nmatrix where each element is the product of the corresponding elements\nin matrix `A` and matrix `B`. It is **not** the standard matrix\nmultiplication for which you should use `%*%` in R.\n\n---\n\n### Add rows or columns to a matrix\n\nSometimes we may want to add new data or information to a matrix with\nmore rows or more columns.\n\nYou can use the `cbind()` function.\n\n    A <- matrix(c(4,3,2,7,4,2,6,3,4,3,0,0,2,-2,-3), byrow=TRUE, nrow=5)\n    B <- matrix(c(1,1,1,2,2,2,0,0,0,-1,-1,-1,0,0,0), byrow=TRUE, nrow=5)\n    big_matrix <- cbind(A, B)\n    big_matrix\n\n    ##      [,1] [,2] [,3] [,4] [,5] [,6]\n    ## [1,]    4    3    2    1    1    1\n    ## [2,]    7    4    2    2    2    2\n    ## [3,]    6    3    4    0    0    0\n    ## [4,]    3    0    0   -1   -1   -1\n    ## [5,]    2   -2   -3    0    0    0\n\nNote:\n\nYou can add a column or multiple columns to a matrix with the `cbind()`\nfunction, which merges matrices and/or vectors together by column. For\nexample, `cbind(A,B)` yields a bigger matrix by merging matrix A and B.\nThe resulting matrix has 5 rows and 6 columns.\n\n---\n\nSimilarly, you can add a row or multiple rows to a matrix with the\n`rbind()` function.\n\n    big_matrix2 <- rbind(A,B)\n    big_matrix2\n\n    ##       [,1] [,2] [,3]\n    ##  [1,]    4    3    2\n    ##  [2,]    7    4    2\n    ##  [3,]    6    3    4\n    ##  [4,]    3    0    0\n    ##  [5,]    2   -2   -3\n    ##  [6,]    1    1    1\n    ##  [7,]    2    2    2\n    ##  [8,]    0    0    0\n    ##  [9,]   -1   -1   -1\n    ## [10,]    0    0    0\n\nNote:\n\nFor example, `big_matrix2 <- rbind(A,B)` returns a bigger matrix by\nputting matrix A on top of matrix B. The resulting matrix has 10 rows\nand 3 columns.\n\n---\n\n### Indexing\n\nYou can use the square brackets (`[ ]`) and comma (`,`) to select one or\nmultiple elements from a matrix.\n\nFor example, `A[1:4,3:5]` returns a matrix with the data on the rows 1,\n2, 3, 4 and columns 3, 4, 5.\n\nIf you want to select all elements of a row or a column, you can do the\nfollowing:\n\n-   `A[,1]` selects all elements of the first column of matrix A.\n-   `A[1,]` selects all elements of the first row of matrix A.\n\nNotes:\n\nSimilar to vectors, you can use the square brackets `[ ]` to select one\nor multiple elements from a matrix. Whereas vectors have one dimension,\nmatrices have two dimensions. You should therefore use a comma to\nseparate the rows you want to select from the columns.\n","fields":{"slug":"/chapter2_05_matrices"}}},{"node":{"rawMarkdownBody":"## Relational operators\n\nRelational operators, or comparators, are operators which help us see\nhow one R object relates to another. The relational operators in R are:\n\n-   `<` for less than\n-   `>` for greater than\n-   `<=` for less than or equal to\n-   `>=` for greater than or equal to\n-   `==` for equal to each other\n-   `!=` not equal to each other\n\n---\n\nYou can use these command on scalar.\n\nFor example,\n\n    8 > 1\n\n    ## [1] TRUE\n\n`8 > 1` return `TRUE` since 8 is larger than 1.\n\n    8 ==1\n\n    ## [1] FALSE\n\n`8 == 1` return `FALSE` since 8 is not equal to 1.\n\nNotes:\n\nRelational operators:\n\n-   `<` for less than\n-   `>` for greater than\n-   `<=` for less than or equal to\n-   `>=` for greater than or equal to\n-   `==` for equal to each other\n-   `!=` not equal to each other\n\n---\n\nThese command also extends to vectors.\n\nFor example,\n\n    c(0,5,100) == 5\n\n    ## [1] FALSE  TRUE FALSE\n\nBoth the first and the last entry evaluates to `FALSE` and only the\nsecond entry returns `TRUE` (equal to 5).\n\nNotes:\n\nRelational operators:\n\n-   `<` for less than\n-   `>` for greater than\n-   `<=` for less than or equal to\n-   `>=` for greater than or equal to\n-   `==` for equal to each other\n-   `!=` not equal to each other\n\nThese command also extends to vectors. It tests for every element of the\nvector if the condition stated by the comparison operator is TRUE or\nFALSE.\n\nYou can see that both the first and the last entry evaluates to `FALSE`\nand only the second entry returns `TRUE` since the second entry is equal\nto 5.\n\n---\n\nNow if instead we do\n\n    c(0,5,100) >= 5\n\n    ## [1] FALSE  TRUE  TRUE\n\nYou can see the output changed since 100 is also greater than or equal\nto 5.\n\nIf we change our code into\n\n    c(0,5,100) < 5\n\n    ## [1]  TRUE FALSE FALSE\n\nYou can see the output changed where the second entry is also `FALSE`\nsince 5 is not strictly less than 5.\n\n---\n\nNote that R also support element-wise comparison if we put a relational\noperator between two vectors:\n\n    c(2,4,6) < c(3,5,7)\n\n    ## [1] TRUE TRUE TRUE\n\n---\n\n## Logical opeators\n\nNext, you can change or combine the results of relational comparisons\nusing:\n\n-   the AND (`&`) operator\n-   the OR (`|`) operator\n-   the NOT (`!`) operator\n\nNotes:\n\nNow you know how to use relational operators in R. Next, what if you\nwant to change or combine the results of these comparisons? In R, you\ncan do this using the AND (`&`), the OR (`|`), and the NOT (`!`)\noperator.\n\n---\n\n**the AND (`&`) operator**\n\nThe AND operator typically takes two logical values and returns TRUE\nonly if both the logical values are TRUE themselves.\n\nFor example, if we check the entries of the following vector x is\ngreater than 2 AND less than 6, we expect `TRUE` for the three entries\nin the middle.\n\n    x = c(1,2,3,4,5,6,7)\n    (x>2)&(x<6)\n\n    ## [1] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n\n---\n\n**the OR (`|`) operator**\n\nThe OR operator (|) works similarly, but the difference is that only at\nleast one of the logical values it uses should be equal to TRUE for the\nentire OR operation to evaluate to TRUE.\n\nFor example,\n\n    x = c(1,2,3,4,5,6,7)\n    (x>4)|(x<2)\n\n    ## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n---\n\n**the NOT (`!`) operator**\n\nThe NOT operator negates the logical value it’s used on.\n\nSay we want to check if an object `a` is a numeric, where `a` is\nactually a string `rain`, we expect the output to be `FALSE`.\n\n    a <- \"rain\"\n    is.numeric(a)\n\n    ## [1] FALSE\n\n    #if the input is actually a number\n    is.numeric(100)\n\n    ## [1] TRUE\n\nNotes:\n\nThe NOT operator negates the logical value it’s used on.\n\nFor example, the built-in R function, is `is.numeric()` checks if an R\nobject is a numeric.\n\nSay we want to check if an object `a` is a numeric, where `a` is\nactually a string `rain`, we expect the output to be `FALSE`.\n\nConsider also object `b` is a number, then the expected output is\n`TRUE`.\n\n---\n\nIf we, instead, use `!is.numeric(a)` to check if `a` is, the output is\nnow `TRUE`.\n\n    !is.numeric(a)\n\n    ## [1] TRUE\n\nAnd when we run `!is.numeric(100)` in R, the output would be `FALSE`.\n\n    !is.numeric(100)\n\n    ## [1] FALSE\n\n---\n\n## Conditional statements\n\nNow we are ready to learn about conditional statements:\n\n-   if\n-   else\n-   else if\n\nNotes:\n\nNow we are ready to learn about conditional statements: if, else, else\nif.\n\nThese conditional statements are very useful in data analysis since\noften we want to treat the data differently depending on certain\nconditions.\n\n---\n\n**if statement**\n\nThe syntax of an if statement looks like this:\n\n    if (condition) {\n      do_this\n    }\n\nSo if the `condition` is evaluated to be `TRUE`, the code included in\nthe curly bracket (`do_this`) will be executed.\n\n---\n\nFor example, `customer_rating` contains a rating (out of 5) from a\ncustomer dined in a restaurant.\n\nWe consider a customer to be happy if the rating is greater than or\nequal to 4.\n\n    customer_rating = 4\n    if (customer_rating >= 4){\n      print(\"Customer is happy!\")\n    }\n\n    ## [1] \"Customer is happy!\"\n\n---\n\n**else statement**\n\nYou can only use an else statement together with an if statement.\n\nThe syntax of an else statement looks like this:\n\n    if (condition) {\n      do_this\n    } else {\n      do_this_instead\n    }\n\nIt’s important that the syntax `else` is on the **same line** as the\nclosing bracket of the if part!\n\nNote:\n\nYou can only use an else statement together with an if statement.\n\nThe else statement does not require a condition.\n\nThe code that comes under the else statement is executed if all of the\nif statements evaluated to be `FALSE`.\n\nSo if the `condition` is evaluated to be `TRUE`, the code included in\nthe first curly bracket (`do_this`) will be executed. Otherwise, the\ncode included in the second curly bracket (`do_this_instead`) will be\nexecuted.\n\nIt’s important that the syntax `else` is on the **same line** as the\nclosing bracket of the if part!\n\n---\n\nFor example, we would like to be alerted if a customer is not happy.\n\n    customer_rating = 2\n    if (customer_rating >= 4){\n      print(\"Customer is happy!\")\n    } else { \n      print(\"Attention - unhappy customer!\")\n    }\n\n    ## [1] \"Attention - unhappy customer!\"\n\n---\n\n**else if statement**\n\nThe else if statement allows you to further customize your control\nstructure.\n\nThe syntax of an else if statement looks like this:\n\n    if (condition1) {\n      action1\n    } else if (condition2) {\n      action2\n    } else if (condition3) {\n      action3\n    } else {\n      action4\n    }\n\nNote:\n\nThe else if statement allows you to further customize your control\nstructure. You can add as many else if statements as you like such that\nyou can customize the action of your code depending on the conditions.\n\n---\n\nFor example, we would like to distinguish between:\n\n-   happy customer (with rating 4 or above),\n-   neutral customer (rating to be less than 4 but higher than 2)\n-   unhappy customer (rating not more than 2).\n\n<!-- -->\n\n    customer_rating = 3\n    if (customer_rating >= 4){\n      print(\"Customer is happy!\")\n    } else if (customer_rating <= 2){ \n      print(\"Attention - unhappy customer!\")\n    } else {\n      print(\"Neutral customer.\")\n    }\n\n    ## [1] \"Neutral customer.\"\n","fields":{"slug":"/chapter2_08_conditionalstatements"}}},{"node":{"rawMarkdownBody":"## Data Transformation and Aggregation\n\n`dplyr` provides a selection of tools for the most common data wrangling\ntasks.\n\n-   `select()`: pick particular variables from your data.\n\n<!-- -->\n\n    table1 %>%\n      select(country)\n\n    ## # A tibble: 6 × 1\n    ##   country    \n    ##   <chr>      \n    ## 1 Afghanistan\n    ## 2 Afghanistan\n    ## 3 Brazil     \n    ## 4 Brazil     \n    ## 5 China      \n    ## 6 China\n\nNote:\n\nThere are a bunch of useful commands to transform and aggregate data in\nR. We will use inbuilt data sets: `table1`, `table2`, `table5` and\n`billboard` for demonstration.\n\n---\n\n### Selection helpers\n\n-   `starts_with()`: select all variables that start with a prefix.\n\n<!-- -->\n\n    billboard %>% select(starts_with(\"wk\"))\n\n    ## # A tibble: 317 × 76\n    ##      wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8   wk9  wk10  wk11  wk12  wk13\n    ##    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n    ##  1    87    82    72    77    87    94    99    NA    NA    NA    NA    NA    NA\n    ##  2    91    87    92    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n    ##  3    81    70    68    67    66    57    54    53    51    51    51    51    47\n    ##  4    76    76    72    69    67    65    55    59    62    61    61    59    61\n    ##  5    57    34    25    17    17    31    36    49    53    57    64    70    75\n    ##  6    51    39    34    26    26    19     2     2     3     6     7    22    29\n    ##  7    97    97    96    95   100    NA    NA    NA    NA    NA    NA    NA    NA\n    ##  8    84    62    51    41    38    35    35    38    38    36    37    37    38\n    ##  9    59    53    38    28    21    18    16    14    12    10     9     8     6\n    ## 10    76    76    74    69    68    67    61    58    57    59    66    68    61\n    ## # … with 307 more rows, and 63 more variables: wk14 <dbl>, wk15 <dbl>,\n    ## #   wk16 <dbl>, wk17 <dbl>, wk18 <dbl>, wk19 <dbl>, wk20 <dbl>, wk21 <dbl>,\n    ## #   wk22 <dbl>, wk23 <dbl>, wk24 <dbl>, wk25 <dbl>, wk26 <dbl>, wk27 <dbl>,\n    ## #   wk28 <dbl>, wk29 <dbl>, wk30 <dbl>, wk31 <dbl>, wk32 <dbl>, wk33 <dbl>,\n    ## #   wk34 <dbl>, wk35 <dbl>, wk36 <dbl>, wk37 <dbl>, wk38 <dbl>, wk39 <dbl>,\n    ## #   wk40 <dbl>, wk41 <dbl>, wk42 <dbl>, wk43 <dbl>, wk44 <dbl>, wk45 <dbl>,\n    ## #   wk46 <dbl>, wk47 <dbl>, wk48 <dbl>, wk49 <dbl>, wk50 <dbl>, wk51 <dbl>, …\n\nNote:\n\nIn addition, you can use **selection helpers**. These helpers select\nvariables by matching patterns in their names.\n\n---\n\n-   `ends_with()`: select all variables that end with a suffix.\n\n<!-- -->\n\n    billboard %>% select(ends_with(\"9\"))\n\n    ## # A tibble: 317 × 7\n    ##      wk9  wk19  wk29  wk39  wk49  wk59 wk69 \n    ##    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <lgl>\n    ##  1    NA    NA    NA    NA    NA    NA NA   \n    ##  2    NA    NA    NA    NA    NA    NA NA   \n    ##  3    51    18     4     9    28    NA NA   \n    ##  4    62    73    NA    NA    NA    NA NA   \n    ##  5    53    NA    NA    NA    NA    NA NA   \n    ##  6     3    93    NA    NA    NA    NA NA   \n    ##  7    NA    NA    NA    NA    NA    NA NA   \n    ##  8    38    83    NA    NA    NA    NA NA   \n    ##  9    12     3    22    NA    NA    NA NA   \n    ## 10    57    79    NA    NA    NA    NA NA   \n    ## # … with 307 more rows\n\nNote:\n\nIn addition, you can use **selection helpers**. These helpers select\nvariables by matching patterns in their names.\n\n---\n\n-   `contains()`: select all variables that contains a literal string.\n\n<!-- -->\n\n    table5 %>% select(contains('ry'))\n\n    ## # A tibble: 6 × 2\n    ##   country     century\n    ##   <chr>       <chr>  \n    ## 1 Afghanistan 19     \n    ## 2 Afghanistan 20     \n    ## 3 Brazil      19     \n    ## 4 Brazil      20     \n    ## 5 China       19     \n    ## 6 China       20\n\nNote:\n\nIn addition, you can use **selection helpers**. These helpers select\nvariables by matching patterns in their names.\n\n---\n\n-   `num_range()`: select all variables that matches a numerical range\n    like x01, x02, x03.\n\n<!-- -->\n\n    billboard %>% select(num_range(\"wk\", 10:15))\n\n    ## # A tibble: 317 × 6\n    ##     wk10  wk11  wk12  wk13  wk14  wk15\n    ##    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n    ##  1    NA    NA    NA    NA    NA    NA\n    ##  2    NA    NA    NA    NA    NA    NA\n    ##  3    51    51    51    47    44    38\n    ##  4    61    61    59    61    66    72\n    ##  5    57    64    70    75    76    78\n    ##  6     6     7    22    29    36    47\n    ##  7    NA    NA    NA    NA    NA    NA\n    ##  8    36    37    37    38    49    61\n    ##  9    10     9     8     6     1     2\n    ## 10    59    66    68    61    67    59\n    ## # … with 307 more rows\n\nNote:\n\nIn addition, you can use **selection helpers**. These helpers select\nvariables by matching patterns in their names.\n\n---\n\nYou can also filter the observations, re-arrange them and add new\nvariables.\n\n-   `filter()`: extract observations from the data based on a given\n    condition\n\n<!-- -->\n\n    table2 %>%\n      filter(year==1999)\n\n    ## # A tibble: 6 × 4\n    ##   country      year type            count\n    ##   <chr>       <int> <chr>           <int>\n    ## 1 Afghanistan  1999 cases             745\n    ## 2 Afghanistan  1999 population   19987071\n    ## 3 Brazil       1999 cases           37737\n    ## 4 Brazil       1999 population  172006362\n    ## 5 China        1999 cases          212258\n    ## 6 China        1999 population 1272915272\n\n---\n\n-   `arrange()`: sort your data based on one or more variables\n\n<!-- -->\n\n    table2 %>%\n      arrange(count)\n\n    ## # A tibble: 12 × 4\n    ##    country      year type            count\n    ##    <chr>       <int> <chr>           <int>\n    ##  1 Afghanistan  1999 cases             745\n    ##  2 Afghanistan  2000 cases            2666\n    ##  3 Brazil       1999 cases           37737\n    ##  4 Brazil       2000 cases           80488\n    ##  5 China        1999 cases          212258\n    ##  6 China        2000 cases          213766\n    ##  7 Afghanistan  1999 population   19987071\n    ##  8 Afghanistan  2000 population   20595360\n    ##  9 Brazil       1999 population  172006362\n    ## 10 Brazil       2000 population  174504898\n    ## 11 China        1999 population 1272915272\n    ## 12 China        2000 population 1280428583\n\n---\n\n-   `mutate()`: add new variables or change existing variables\n\n<!-- -->\n\n    table1 %>%\n      mutate(rate = cases/population)\n\n    ## # A tibble: 6 × 5\n    ##   country      year  cases population      rate\n    ##   <chr>       <int>  <int>      <int>     <dbl>\n    ## 1 Afghanistan  1999    745   19987071 0.0000373\n    ## 2 Afghanistan  2000   2666   20595360 0.000129 \n    ## 3 Brazil       1999  37737  172006362 0.000219 \n    ## 4 Brazil       2000  80488  174504898 0.000461 \n    ## 5 China        1999 212258 1272915272 0.000167 \n    ## 6 China        2000 213766 1280428583 0.000167\n\n---\n\n-   `group_by()` and `ungroup()`: takes existing data and groups\n    specific variables together for future operations.\n\n<!-- -->\n\n    table2 %>% \n      group_by(type) %>% \n      summarize(min = min(count), max =max(count))\n\n    ## # A tibble: 2 × 3\n    ##   type            min        max\n    ##   <chr>         <int>      <int>\n    ## 1 cases           745     213766\n    ## 2 population 19987071 1280428583\n\nNote:\n\nThese two functions are often used together with other `dplyr`\nfunctions. We will introduce them with the `summarize()` function. The\n`summarize()` function creates a new dataframe based on the argument\nprovided.\n\n---\n\nYou can summarize the data in different ways based on the groupings and\ndifferent argument you included.\n\n    table2 %>% \n      group_by(type) %>% \n      summarize(mean(count), median(count),sd(count))\n\n    ## # A tibble: 2 × 4\n    ##   type       `mean(count)` `median(count)` `sd(count)`\n    ##   <chr>              <dbl>           <dbl>       <dbl>\n    ## 1 cases             91277.          59112.      98662.\n    ## 2 population    490072924.      173255630   613130267.\n\nNote:\n\nThese two functions are often used together with other `dplyr`\nfunctions. We will introduce them with the `summarize()` function. The\n`summarize()` function creates a new dataframe based on the argument\nprovided.\n\n---\n\n-   `count()`: a convenient way to get a sense of the distribution of\n    values in a data set.\n\n<!-- -->\n\n    table2 %>% count(country)\n\n    ## # A tibble: 3 × 2\n    ##   country         n\n    ##   <chr>       <int>\n    ## 1 Afghanistan     4\n    ## 2 Brazil          4\n    ## 3 China           4\n\n---\n\n-   `case_when()`: This command takes multiple conditions and tests them\n    in order.\n\n<!-- -->\n\n    table1 %>% \n      mutate(band = case_when(cases>= 1000 & cases <=100000~ \"Medium\",\n                              cases > 100000 ~ \"High\",\n                              TRUE ~ \"Low\"))\n\n    ## # A tibble: 6 × 5\n    ##   country      year  cases population band  \n    ##   <chr>       <int>  <int>      <int> <chr> \n    ## 1 Afghanistan  1999    745   19987071 Low   \n    ## 2 Afghanistan  2000   2666   20595360 Medium\n    ## 3 Brazil       1999  37737  172006362 Medium\n    ## 4 Brazil       2000  80488  174504898 Medium\n    ## 5 China        1999 212258 1272915272 High  \n    ## 6 China        2000 213766 1280428583 High\n\nNote:\n\nFor `case_when()`, you should order the tests from specific to general,\nand keep track of how those ambiguous rows are being treated. `TRUE`\nhere is equivalent to the `else` statement.\n\n---\n\n## Joining Datasets\n\nWe are going to use the following tables in our example.\n\n    homework1 <- tibble(name = c('Alphonso', 'Daisy', 'Philip'), \n                        student_no = c(456,100,102), marks = c(80, 65, 34))\n    homework2 <- tibble(name = c('Alphonso', 'Philip', 'Melinda'), \n                        student_no = c(456,102,432), marks = c(85, 97, 56))\n\nNote:\n\nOften you will need information from multiple datasets in your data\nanalysis. It is important to learn different types of joins to\naccommodate different needs in your tasks.\n\nWe are going to use the following tables in our example. Consider there\nare 4 students in a class and they submitted homework 1 and homework 2.\nThe tables contains their scores for the homeworks (gradebook) and not\neveryone submitted their homework during the semester.\n\n---\n\n### Mutating Joins\n\nMutation joins return a copy of the dataset that has been augmented.\n\n---\n\n**Inner Join**\n\nInner joins retain only rows that exists on both datasets.\n\n    inner_join(homework1, homework2, by = c('name','student_no'))\n\n    ## # A tibble: 2 × 4\n    ##   name     student_no marks.x marks.y\n    ##   <chr>         <dbl>   <dbl>   <dbl>\n    ## 1 Alphonso        456      80      85\n    ## 2 Philip          102      34      97\n\nNote:\n\nWhen we perform inner join by `name` and `student_no`, R only returns\nrows that exists in both data set. When we do inner join with our\n`homework1` and `homework2` gradebooks, only `Alphonso` and `Philip` ’s\nmarks will show up since they are the only ones that submitted both\nhomeworks.\n\n---\n\n**Left Join**\n\nLeft joins starts with the left data set (`homework1`) and search in the\nright data set looking for the same values of `name` and `student_no` to\nadd to the left data set.\n\n    left_join(homework1, homework2, by = c('name','student_no'))\n\n    ## # A tibble: 3 × 4\n    ##   name     student_no marks.x marks.y\n    ##   <chr>         <dbl>   <dbl>   <dbl>\n    ## 1 Alphonso        456      80      85\n    ## 2 Daisy           100      65      NA\n    ## 3 Philip          102      34      97\n\nNote:\n\nWhen we do left join with our `homework1` and `homework2` gradebooks, we\nwill only consider those students who submitted homework 1 and look for\ntheir marks in homework 2. Melinda’s result will not be included in the\njoin even though she has submitted her homework 2, while Daisy will have\n`NA` showing as the missing value.\n\n---\n\n**Right Join**\n\nRight joins starts with the right data set (homework2) and search in the\nleft data set looking for the same values of `name` and `student_no` to\nadd to the right data set.\n\n    right_join(homework1, homework2, by = c('name','student_no'))\n\n    ## # A tibble: 3 × 4\n    ##   name     student_no marks.x marks.y\n    ##   <chr>         <dbl>   <dbl>   <dbl>\n    ## 1 Alphonso        456      80      85\n    ## 2 Philip          102      34      97\n    ## 3 Melinda         432      NA      56\n\nNote:\n\nWhen we do right join with our `homework1` and `homework2` gradebooks,\nwe will only consider those students who submitted homework 2 and look\nfor their marks in homework 1. Daisy’s result will not be included in\nthe join even though she has submitted her homework 1, while Melinda\nwill have `NA` showing as the missing value.\n\n---\n\n**Full Join**\n\nFull joins retain all rows.\n\n    full_join(homework1, homework2, by = c('name','student_no'))\n\n    ## # A tibble: 4 × 4\n    ##   name     student_no marks.x marks.y\n    ##   <chr>         <dbl>   <dbl>   <dbl>\n    ## 1 Alphonso        456      80      85\n    ## 2 Daisy           100      65      NA\n    ## 3 Philip          102      34      97\n    ## 4 Melinda         432      NA      56\n\nAll the submissions with the corresponding mark are included in the full\njoin of the gradebook.\n\n---\n\n### Filtering Joins\n\nFiltering joins return a copy of the dataset that has been filtered.\n\n---\n\n**Semi Join**\n\nThe semi join returns a filtered version of the left data set based on\nmatching entries in the right data set.\n\n    semi_join(homework1, homework2, by = c('name','student_no'))\n\n    ## # A tibble: 2 × 3\n    ##   name     student_no marks\n    ##   <chr>         <dbl> <dbl>\n    ## 1 Alphonso        456    80\n    ## 2 Philip          102    34\n\n    semi_join(homework2, homework1, by = c('name','student_no'))\n\n    ## # A tibble: 2 × 3\n    ##   name     student_no marks\n    ##   <chr>         <dbl> <dbl>\n    ## 1 Alphonso        456    85\n    ## 2 Philip          102    97\n\n---\n\n**Anti Join**\n\nNow, let’s say we want to know who didn’t submit homeworks. The anti\njoin will return the rows in the left data set that doesn’t have an\nentry in the right data set.\n\n    anti_join(homework1, homework2, by = c('name','student_no'))\n\n    ## # A tibble: 1 × 3\n    ##   name  student_no marks\n    ##   <chr>      <dbl> <dbl>\n    ## 1 Daisy        100    65\n\n    anti_join(homework2, homework1, by = c('name','student_no'))\n\n    ## # A tibble: 1 × 3\n    ##   name    student_no marks\n    ##   <chr>        <dbl> <dbl>\n    ## 1 Melinda        432    56\n","fields":{"slug":"/chapter6_02_dplyr"}}},{"node":{"rawMarkdownBody":"## Tidy (reshape) your data\n\nA tidy data format:\n\n-   Each column should hold a single variable\n-   each row should hold a single observation\n-   each cell should hold a single value.\n\nExamine `table1`, `table2` and `table3`.\n\nThey show the same information in 3 different ways.\n\n---\n\nTable 1\n\n    table1\n\n    ## # A tibble: 6 × 4\n    ##   country      year  cases population\n    ##   <chr>       <int>  <int>      <int>\n    ## 1 Afghanistan  1999    745   19987071\n    ## 2 Afghanistan  2000   2666   20595360\n    ## 3 Brazil       1999  37737  172006362\n    ## 4 Brazil       2000  80488  174504898\n    ## 5 China        1999 212258 1272915272\n    ## 6 China        2000 213766 1280428583\n\nNote:\n\nRaw data that we acquired can often be messy and complicated. The tidyr\npackage allows you to wrangle messy datasets into nice and tidy ones.\n\nA tidy data format has a rectangular shape which means it has columns,\nrows, and cells, just like in a spreadsheet. Each column should hold a\nsingle variable, each row should hold a single observation and each cell\nshould hold a single value.\n\nThe example on the left shows the same information (country, year,\npopulation, and number of cases) organised in 3 different ways. Examine\neach of the table.\n\n---\n\nTable 2\n\n    table2\n\n    ## # A tibble: 12 × 4\n    ##    country      year type            count\n    ##    <chr>       <int> <chr>           <int>\n    ##  1 Afghanistan  1999 cases             745\n    ##  2 Afghanistan  1999 population   19987071\n    ##  3 Afghanistan  2000 cases            2666\n    ##  4 Afghanistan  2000 population   20595360\n    ##  5 Brazil       1999 cases           37737\n    ##  6 Brazil       1999 population  172006362\n    ##  7 Brazil       2000 cases           80488\n    ##  8 Brazil       2000 population  174504898\n    ##  9 China        1999 cases          212258\n    ## 10 China        1999 population 1272915272\n    ## 11 China        2000 cases          213766\n    ## 12 China        2000 population 1280428583\n\nNote:\n\nRaw data that we acquired can often be messy and complicated. The tidyr\npackage allows you to wrangle messy datasets into nice and tidy ones.\n\nA tidy data format has a rectangular shape which means it has columns,\nrows, and cells, just like in a spreadsheet. Each column should hold a\nsingle variable, each row should hold a single observation and each cell\nshould hold a single value.\n\nThe example on the left shows the same information (country, year,\npopulation, and number of cases) organised in 3 different ways. Examine\neach of the table.\n\n---\n\nTable 3\n\n    table3\n\n    ## # A tibble: 6 × 3\n    ##   country      year rate             \n    ## * <chr>       <int> <chr>            \n    ## 1 Afghanistan  1999 745/19987071     \n    ## 2 Afghanistan  2000 2666/20595360    \n    ## 3 Brazil       1999 37737/172006362  \n    ## 4 Brazil       2000 80488/174504898  \n    ## 5 China        1999 212258/1272915272\n    ## 6 China        2000 213766/1280428583\n\nNote:\n\nRaw data that we acquired can often be messy and complicated. The tidyr\npackage allows you to wrangle messy datasets into nice and tidy ones.\n\nA tidy data format has a rectangular shape which means it has columns,\nrows, and cells, just like in a spreadsheet. Each column should hold a\nsingle variable, each row should hold a single observation and each cell\nshould hold a single value.\n\nThe example below shows the same information (country, year, population,\nand number of cases) organised in 3 different ways. Examine each of the\ntable.\n\n---\n\nR functions to tidy the data:\n\n-   `separate()`: separating multiple variables in one column to\n    different columns.\n-   `unite()`: merging multiple columns into one, inserting underscore\n    (`_`) as a separator between the two inputs.\n-   `separate_rows()`: separating multiple observations in the same\n    cell. We pass the messy column name and a string to use as a\n    separator.\n\nNote:\n\nSometimes raw data may have multiple variables or multiple values (not\nthe same variable) in the same column, or sometimes you may want to\nmerge multiple columns into one. Here are a few commands that can be\nhelpful in manipulating the data into a tidy format.\n\n---\n\nIn table 3, the `rate` column contains both the number of cases and the\nsize of the populations.\n\nWe want to separate the `rate` variable into variables `cases` and\n`population`.\n\n    table3 %>%\n      separate(rate, into = c(\"cases\", \"population\"), sep = \"/\", convert = TRUE)\n\n    ## # A tibble: 6 × 4\n    ##   country      year  cases population\n    ##   <chr>       <int>  <int>      <int>\n    ## 1 Afghanistan  1999    745   19987071\n    ## 2 Afghanistan  2000   2666   20595360\n    ## 3 Brazil       1999  37737  172006362\n    ## 4 Brazil       2000  80488  174504898\n    ## 5 China        1999 212258 1272915272\n    ## 6 China        2000 213766 1280428583\n\nNote:\n\n-   The `into` argument expects a vector of column names.\n-   The `sep` argument expects the non-alphanumeric character (a\n    character that is not a letter or a number) that we split upon.\n-   The `convert` argument is set to TRUE here so that R will try and\n    convert to better types after the split.\n\n---\n\nIn table 5, the `century` and `year` column can be combined to give a\n`year_new` column.\n\n    table5 %>%\n      unite(new_year,century, year, sep = \"\")\n\n    ## # A tibble: 6 × 3\n    ##   country     new_year rate             \n    ##   <chr>       <chr>    <chr>            \n    ## 1 Afghanistan 1999     745/19987071     \n    ## 2 Afghanistan 2000     2666/20595360    \n    ## 3 Brazil      1999     37737/172006362  \n    ## 4 Brazil      2000     80488/174504898  \n    ## 5 China       1999     212258/1272915272\n    ## 6 China       2000     213766/1280428583\n\nNote:\n\nThe `sep` argument here is what comes in between the values from\ndifferent columns. If we don’t want anything in between, we can use ““.\n\n---\n\nIn table 6, there are multiple observations in the same cell in each row\nof `year` and `cases`.\n\nWe would like to separate them.\n\n    table6 <- tibble(country = c(\"Afghanistan\", \"Brazil\", \"China\"),\n      year = c(\"1999,2000\", \"1999,2000\", \"1999,2000\"),\n      cases= c(\"745,2666\", \"37737,80488\", \"212258,213766\"))\n\n    table6 %>% separate_rows(cases, year, sep=',', convert = TRUE)\n\n    ## # A tibble: 6 × 3\n    ##   country      year  cases\n    ##   <chr>       <int>  <int>\n    ## 1 Afghanistan  1999    745\n    ## 2 Afghanistan  2000   2666\n    ## 3 Brazil       1999  37737\n    ## 4 Brazil       2000  80488\n    ## 5 China        1999 212258\n    ## 6 China        2000 213766\n\n---\n\n## Pivoting\n\nTwo common problems in raw data set:\n\n-   some of the column names are not really names of variables, but\n    **values** of a variable.\n-   when an observation is scattered across multiple rows.\n\nTo tackle these problems, you will need `pivot_longer()` and/or\n`pivot_wider()`\n\n---\n\n**pivot\\_longer()**\n\n`table4a` is a great example of data that needs `pivot_longer()`.\n\nHere you see that the case count of each country is separated into two\ncolumns because they are from different years.\n\n    table4a\n\n    ## # A tibble: 3 × 3\n    ##   country     `1999` `2000`\n    ## * <chr>        <int>  <int>\n    ## 1 Afghanistan    745   2666\n    ## 2 Brazil       37737  80488\n    ## 3 China       212258 213766\n\n    table4a %>% \n      pivot_longer(c(`1999`, `2000`), names_to = \"year\", values_to = \"cases\")\n\n    ## # A tibble: 6 × 3\n    ##   country     year   cases\n    ##   <chr>       <chr>  <int>\n    ## 1 Afghanistan 1999     745\n    ## 2 Afghanistan 2000    2666\n    ## 3 Brazil      1999   37737\n    ## 4 Brazil      2000   80488\n    ## 5 China       1999  212258\n    ## 6 China       2000  213766\n\nNotes:\n\n-   The first argument is the vector of column names that are actually\n    values not variables.\n-   The second argument is the name of the variable to move the column\n    **names** to.\n-   The third argument is the name of the variable to move the column\n    **values** to.\n\n---\n\n**pivot\\_wider()**\n\nIn table 2, each observation is a certain country in a certain year.\n\nHowever, the observation is spread across two rows since there are\n`cases` and `population`.\n\n    table2\n\n    ## # A tibble: 12 × 4\n    ##    country      year type            count\n    ##    <chr>       <int> <chr>           <int>\n    ##  1 Afghanistan  1999 cases             745\n    ##  2 Afghanistan  1999 population   19987071\n    ##  3 Afghanistan  2000 cases            2666\n    ##  4 Afghanistan  2000 population   20595360\n    ##  5 Brazil       1999 cases           37737\n    ##  6 Brazil       1999 population  172006362\n    ##  7 Brazil       2000 cases           80488\n    ##  8 Brazil       2000 population  174504898\n    ##  9 China        1999 cases          212258\n    ## 10 China        1999 population 1272915272\n    ## 11 China        2000 cases          213766\n    ## 12 China        2000 population 1280428583\n\n    table2 %>%\n      pivot_wider(names_from = type, values_from = count)\n\n    ## # A tibble: 6 × 4\n    ##   country      year  cases population\n    ##   <chr>       <int>  <int>      <int>\n    ## 1 Afghanistan  1999    745   19987071\n    ## 2 Afghanistan  2000   2666   20595360\n    ## 3 Brazil       1999  37737  172006362\n    ## 4 Brazil       2000  80488  174504898\n    ## 5 China        1999 212258 1272915272\n    ## 6 China        2000 213766 1280428583\n\nNotes:\n\n-   The first argument is the column to take variable **names** from,\n    which is `type`.\n-   The second argument is the column to take variable **values** from,\n    where is `count`.\n\n---\n\n## Missing values\n\nThere are various ways to handle missing values (the `NA`s) in your data\nset.\n\nTidyr has three functions:\n\n-   `fill()`: fill the missing values using the last observation carried\n    forward. It has a `.direction` argument that you can pass `up` or\n    `down`.\n-   `drop_na()`: drop the rows with observations that are `NA`\n-   `replace_na()`: replace the `NA` with specific values\n\n---\n\nLet’s look at this toy data set.\n\nWe will start with the `fill()` function to impute the `return` column\nin the `up` direction, then we will impute in the `down` direction.\n\nCan you spot the difference?\n\n    apple <- tibble(\n      year   = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),\n      qtr    = c(   1,    2,    3,    4,    2,    3,    4),\n      return = c(0.75, 0.39, 0.34,   NA, 0.99, 0.07, 1.88)\n    )\n\n    apple %>%\n      fill(return, .direction = \"up\")\n\n    ## # A tibble: 7 × 3\n    ##    year   qtr return\n    ##   <dbl> <dbl>  <dbl>\n    ## 1  2020     1   0.75\n    ## 2  2020     2   0.39\n    ## 3  2020     3   0.34\n    ## 4  2020     4   0.99\n    ## 5  2021     2   0.99\n    ## 6  2021     3   0.07\n    ## 7  2021     4   1.88\n\n    apple %>%\n      fill(return, .direction = \"down\")\n\n    ## # A tibble: 7 × 3\n    ##    year   qtr return\n    ##   <dbl> <dbl>  <dbl>\n    ## 1  2020     1   0.75\n    ## 2  2020     2   0.39\n    ## 3  2020     3   0.34\n    ## 4  2020     4   0.34\n    ## 5  2021     2   0.99\n    ## 6  2021     3   0.07\n    ## 7  2021     4   1.88\n\n---\n\nThen, we will try to drop the `NA`s in the return in `apple`.\n\n    apple %>%\n      drop_na(return)\n\n    ## # A tibble: 6 × 3\n    ##    year   qtr return\n    ##   <dbl> <dbl>  <dbl>\n    ## 1  2020     1   0.75\n    ## 2  2020     2   0.39\n    ## 3  2020     3   0.34\n    ## 4  2021     2   0.99\n    ## 5  2021     3   0.07\n    ## 6  2021     4   1.88\n\n---\n\nFinally, we will also replace the `NA`s with the value `999`.\n\n    apple %>%\n      replace_na(list(return=999))\n\n    ## # A tibble: 7 × 3\n    ##    year   qtr return\n    ##   <dbl> <dbl>  <dbl>\n    ## 1  2020     1   0.75\n    ## 2  2020     2   0.39\n    ## 3  2020     3   0.34\n    ## 4  2020     4 999   \n    ## 5  2021     2   0.99\n    ## 6  2021     3   0.07\n    ## 7  2021     4   1.88\n","fields":{"slug":"/chapter6_04_tidyr"}}},{"node":{"rawMarkdownBody":"\n\n\n\n---\n\n## Facets \n\n* Faceting in `ggplot2` refers to partitioning of the plot region to multiple panels each showing a different subset of the data.\n* There are three types of faceting:\n\n  * `facet_null()` (the default),\n  * `facet_wrap()`, and\n  * `facet_grid()`.\n\n---\n\n## Motivating data: growth of soybean\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(davidian.soybean, package = \"agridat\")\nstr(davidian.soybean)\n```\n\n::: {.cell-output-stdout}\n```\n'data.frame':\t412 obs. of  5 variables:\n $ plot   : Factor w/ 48 levels \"1988F1\",\"1988F2\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ variety: Factor w/ 2 levels \"F\",\"P\": 1 1 1 1 1 1 1 1 1 1 ...\n $ year   : int  1988 1988 1988 1988 1988 1988 1988 1988 1988 1988 ...\n $ day    : int  14 21 28 35 42 49 56 63 70 77 ...\n $ weight : num  0.106 0.261 0.666 2.11 3.56 ...\n```\n:::\n:::\n\n* The data contains:\n  * `plot`: the plot code\n  * `variety`: the code (`F` = commercial and `P` = experimental) for which soybean variety\n  * `year`: the year it was grown (1988-1990)\n  * `day` days after planting\n  * `weight` weight of soybean leaves\n\n---\n\n## `facet_wrap()`\n\n* `facet_wrap()` divides the data into mutually exclusive subset based on the input variable and create subplots based on the data in the corresponding panel.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(davidian.soybean, aes(day, weight)) + \n  geom_point() +\n  facet_wrap(~year)\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/facet-wrap-demo-1.png){fig-align='center' width=960}\n:::\n:::\n\n---\n\n## Wrapping many panels\n\n* It \"wraps\" the panels into 2d if you have many panels\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(davidian.soybean, aes(day, weight)) + \n  geom_point() +\n  facet_wrap(~plot)\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/facet-wrap-demo-wrap-1.png){fig-align='center' width=960}\n:::\n:::\n\n---\n\n## Wrapping by a continuous variable\n\n* If you want to wrap the facet by a continuous variable, then you first need to discretize the continuous variable, e.g. using `cut()`, `cut_width()`, `cut_interval()` or `cut_number()`.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(davidian.soybean, aes(day, weight)) + \n  geom_point() +\n  facet_wrap(~cut_number(day, 4))\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/facet-wrap-demo-cont-1.png){fig-align='center' width=960}\n:::\n:::\n\n---\n\n## Changing the scales for each panel\n\n* By default the scales are shared across the panels but you can choose to have scales  built independently for each panel:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(davidian.soybean, aes(day, weight)) + \n  geom_point() +\n  facet_wrap(~cut_number(day, 4), scales = \"free\")\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/facet-wrap-demo-cont-scales-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n---\n\n## Wrapping with more than one variables\n\n* If you want to wrap the facet by more than one variable, you can combine the variables by using `+`:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(davidian.soybean, aes(day, weight)) + \n  geom_point() +\n  facet_wrap(~ year + variety)\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/facet-wrap-demo-interaction-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n---\n\n## `facet_grid()`\n\n* Alternatively, you can use `facet_grid()` to lay out the panels in a 2d grid:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(davidian.soybean, aes(day, weight)) + \n  geom_point() +\n  facet_grid(variety ~ year)\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/facet-grid-demo-1.png){fig-align='center' width=960}\n:::\n:::\n\n---\n\n## Missing facet variables\n\n* If a layer data is missing the faceting variable(s), then the layer will be shown across all panels based on all of the layer data\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(davidian.soybean, aes(day, weight)) + \n  geom_point(data = dplyr::select(davidian.soybean, -c(variety, year)),\n             color = \"grey70\") +\n  geom_point() +\n  facet_grid(variety ~ year)\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/facet-all-1.png){fig-align='center' width=960}\n:::\n:::\n\n---\n\n## Combining plots with `patchwork`\n\n* We use the `patchwork` package for combining plots.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(patchwork)\n```\n:::\n* Combining multiple `ggplot` objects is then just a matter of using `+` (side-by-side) or `/` (top-to-bottom).\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng1 <- ggplot(davidian.soybean, aes(day, weight)) +\n  geom_point(aes(color = as.factor(year))) \ng2 <- ggplot(davidian.soybean, aes(as.factor(year), weight)) +\n  geom_jitter(aes(color = as.factor(year))) \ng1 + g2\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/patchwork-demo-1.png){fig-align='center' width=960}\n:::\n:::\n\n---\n\n### Combining plot layouts\n\n* `patchwork` can collect the same guides across the plots as well as automatically add tag labels\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng1 + g2 + \n  plot_layout(guides = \"collect\") + \n  plot_annotation(tag_levels = \"A\")\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/patchwork-layouts-1.png){fig-align='center' width=960}\n:::\n:::\n\n---\n\n### Plot layout\n\n* You can combine the use of `+` and `/` to layout plots horizontally or vertically using `(` to group rows or columns\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(g1 + g2) / (g2 + g1) + \n  plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/patchwork-layout-1.png){fig-align='center' width=960}\n:::\n:::\n\n---\n\n## Flexible plot layout\n\n* If you want even more control over the plot layout, then you can specify a strinng with the structure you want like below:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndesign <- \"\n 11###\n 11###\n #2222\"\n\ng1 + g2 + \n  plot_layout(guides = \"collect\",\n              design = design)\n```\n\n::: {.cell-output-display}\n![](images/chapter7-05/patchwork-design-1.png){fig-align='center' width=960}\n:::\n:::\n","fields":{"slug":"/chapter7_05_ggplot2facet"}}},{"node":{"rawMarkdownBody":"## Example slides\n\nHere are some slides. You can use these to demonstrate the concept\nbefore testing their understanding with tasks.\n\nFocus on content, not style when writing the slides to achieve a uniform\ndesign.\n\nTo separate content onto the next slide, use `---` on a new line.\n\n---\n\nIn slides you can provide R code examples;\n\n    library(tidyverse)\n\n    ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n\n    ## ✓ ggplot2 3.3.5.9000     ✓ purrr   0.3.4     \n    ## ✓ tibble  3.1.6          ✓ dplyr   1.0.7     \n    ## ✓ tidyr   1.1.4          ✓ stringr 1.4.0     \n    ## ✓ readr   2.0.2          ✓ forcats 0.5.1\n\n    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n    ## x dplyr::filter() masks stats::filter()\n    ## x dplyr::lag()    masks stats::lag()\n\n    mtcars %>% \n      ggplot(aes(x = factor(cyl), y = mpg)) + \n      geom_boxplot()\n\n![](slides_example_files/figure-markdown_strict/unnamed-chunk-1-1.png)\n","fields":{"slug":"/slides_example"}}}]}}}