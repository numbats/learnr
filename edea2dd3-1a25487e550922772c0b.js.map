{"version":3,"sources":["webpack:///./node_modules/@jupyterlab/codemirror/node_modules/codemirror/keymap/vim.js"],"names":["CodeMirror","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","replace","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","Vim","detachVimMap","cm","next","this","keyMap","vim","rmClass","getWrapperElement","getOption","document","body","style","caretColor","marks","state","fatCursorMarks","i","length","clear","off","updateFatCursorMark","disableFatCursorMark","getInputField","attach","attachVimMap","setOption","onCursorActivity","getOnPasteFn","leaveVimMode","prev","addClass","on","enableFatCursorMark","signal","mode","maybeInitVimState","enterVimMode","ranges","listSelections","result","range","empty","anchor","ch","getLine","line","push","markText","className","widget","createElement","textContent","setBookmark","cmKey","key","vimKey","charAt","pieces","split","lastPiece","hasCharacter","piece","modifiers","specialKeys","isUpperCase","toLowerCase","join","cmKeyToVimKey","cmd","findKey","defineOption","val","Init","test","Enter","Backspace","Delete","Insert","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","bigWordCharTest","makeKeyRange","start","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","firstLine","lastLine","isLowerCase","k","isWhiteSpaceString","isEndOfSentenceSymbol","indexOf","inArray","arr","options","defaultValue","aliases","callback","undefined","Error","value","cfg","option","scope","local","vimGlobalState","lastInsertModeKeyTimer","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","pointer","head","tail","buffer","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","Array","cachedCursor","add","oldCur","newCur","curMark","useNextSlot","cursor","trashMark","markPos","find","cursorEqual","move","offset","mark","inc","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","prototype","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","openDialog","bottom","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","handleMacroRecording","clearInputState","pushText","logKey","handleEsc","exitVisualMode","exitInsertMode","keyBuffer","keysAreChars","match","commandDispatcher","matchCommand","slice","thisMatch","window","clearTimeout","setTimeout","selections","here","replaceRange","pop","handleKeyInsertMode","keysMatcher","exec","pushRepeatDigit","handleKeyNonInsertMode","operation","curOp","isVimOp","substring","index","doKeyToKey","processCommand","e","console","handleEx","input","defineMotion","fn","motions","defineAction","defineOperator","operators","mapCommand","args","extra","_mapCommand","defineRegister","registers","prefixRepeat","motionRepeat","reason","Register","text","insertModeChanges","searchQueries","unnamedRegister","historyBuffer","iterator","initialPrefix","n","getRepeat","repeat","parseInt","setText","pushInsertModeChanges","pushSearchQuery","query","toString","isValidRegister","shiftNumericRegisters_","nextMatch","up","dir","element","j","pushInput","splice","reset","bestMatch","matches","partial","full","commandMatch","commandMatches","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","shift","showPrompt","onClose","scrollTo","left","top","logSearchQuery","desc","searchPromptDesc","onKeyUp","close","parsedQuery","keyName","target","selectionEnd","selectionStart","Math","min","updateSearchQuery","scrollIntoView","_findNext","clearSearchHighlight","onKeyDown","e_stop","focus","word","expandWordUnderCursor","isKeyword","end","ignoreCase","smartCase","showConfirm","onPromptClose","onPromptKeyDown","exArgs","selectValueOnOpen","newHead","newAnchor","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","recordJumpPosition","Infinity","updateCmSelection","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","tmp","_cm","expandSelectionToLine","selection","getRange","lines","clipToLine","setSelections","primary","operatorMoveTo","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","floor","moveToBottomLine","expandToLine","findNext","isReversed","highlightSearchMatches","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","equal","between","cursorIsBetween","moveByCharacters","cur","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","moveToStartOfLine","charCoords","res","findPosV","hitSide","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","nextChar","idx","ln","stop","curr","last_valid","skip_empty_lines","reverse","curr_index","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","words","emptyLineIsWord","findWord","eodCh","from","to","shortCircuit","firstWord","lastWord","moveToWord","moveTillCharacter","_moveToCharacter","recordLastCharacterSearch","moveToCharacter","moveToSymbol","symb","endLine","lineCount","curCh","lineText","nextCh","lastCh","reverseSymb","depth","curMoveThrough","symbolToMode","init","findSymbolModes","isComplete","lineLen","findSymbol","_moveToColumn","retval","clipPos","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","getTokenTypeAt","findMatchingBracket","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","bracketRegexp","openSym","scanForBracket","selectCompanionObject","'","len","chars","firstIndex","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fillArray","times","change","finalHead","inVisualBlock","getSelection","replacement","replaceSelections","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","commands","newlineAndIndent","indent","startLine","indentLine","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","max","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","lastSelectionCurEnd","selectedArea","getCurrentSelectedAreaRange","block","width","setSelection","getLastSelectedAreaRange","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","re","baseStr","digits","base","zeroPadding","substr","repeatLastEdit","_repeatLastEdit","includeLineBreak","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","isClipped","primIndex","atAnchor","atHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","updateFakeCursor","exclusive","headOffset","anchorOffset","right","moveHead","firstNonWS","search","_forward","noSymbol","getHead","wordStart","bracket","section","comment","found","method","preprocess","token","charTests","foundWord","charIdxInLine","markName","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","SearchState","searchState_","dialog","template","shortText","prompt","splitBySeparator","argString","separator","slashes","findUnescapedSeparators","tokens","escapeNextChar","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","unescapes","parseQuery","RegExp","regexPart","forceIgnoreCase","out","specialComesNext","translateRegex","openNotification","duration","alert","raw","rawQuery","r1","r2","props","regexEqual","searchState","removeOverlay","source","matchSol","stream","sol","backUp","eol","skipToEnd","addOverlay","showMatchesOnScrollbar","scrollInfo","bottomY","history","doc","done","event","lastModTime","changeHistory","filter","el","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","StringStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","mapping","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","number","pattern","err","eatSpace","opts","decimal","hex","octal","parseArgs","lineStart","radix","numPart","textPart","matchPart","a","b","compareFn","textOld","anum","bnum","global","splitBySlash","matchedLines","content","nextCommand","substitute","trailing","flagsPart","count","replacePart","confirm","output","peek","matched","matcher","unescapeRegexReplace","translateRegexReplace","startPos","searchCursor","exMode","lastPos","replaceAll","newText","_value","savedCallback","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","insertModeChangeRegister","lastChange","selLength","logInsertModeChange","imc","repeatInsertModeChanges","changeObj","maybeReset","somethingSelected","handleExternalSelection","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","getOffset","detach","fallthrough","mod"],"mappings":"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","file":"edea2dd3-1a25487e550922772c0b.js","sourcesContent":["require(\"core-js/modules/es.array.sort.js\");\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [// Key to key mapping. This goes first to make it possible to override\n  // existing mappings.\n  {\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h',\n    context: 'normal'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B',\n    context: 'normal'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b',\n    context: 'normal'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  }, // Motions\n  {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, // the next two aren't motions but must come before more general motion declarations\n  {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  }, // Operators\n  {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, // Operator-Motion dual commands\n  {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  }, // Actions\n  {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<character>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<character>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  }, // Handle Replace-mode as a special case of insert mode.\n  {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    }\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<character>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<character>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  }, // Text object motions\n  {\n    keys: 'a<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  }, // Search\n  {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, // Ex command\n  {\n    keys: ':',\n    type: 'ex'\n  }];\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function Vim() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          disableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"\";\n        }\n      }\n\n      if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n    }\n\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          enableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"transparent\";\n        }\n      }\n\n      if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n    }\n\n    function fatCursorMarks(cm) {\n      var ranges = cm.listSelections(),\n          result = [];\n\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n\n        if (range.empty()) {\n          if (range.anchor.ch < cm.getLine(range.anchor.line).length) {\n            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1), {\n              className: \"cm-fat-cursor-mark\"\n            }));\n          } else {\n            var widget = document.createElement(\"span\");\n            widget.textContent = \"\\xA0\";\n            widget.className = \"cm-fat-cursor-mark\";\n            result.push(cm.setBookmark(range.anchor, {\n              widget: widget\n            }));\n          }\n        }\n      }\n\n      return result;\n    }\n\n    function updateFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks;\n      if (marks) for (var i = 0; i < marks.length; i++) {\n        marks[i].clear();\n      }\n      cm.state.fatCursorMarks = fatCursorMarks(cm);\n    }\n\n    function enableFatCursorMark(cm) {\n      cm.state.fatCursorMarks = fatCursorMarks(cm);\n      cm.on(\"cursorActivity\", updateFatCursorMark);\n    }\n\n    function disableFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks;\n      if (marks) for (var i = 0; i < marks.length; i++) {\n        marks[i].clear();\n      }\n      cm.state.fatCursorMarks = null;\n      cm.off(\"cursorActivity\", updateFatCursorMark);\n    } // Deprecated, simply setting the keymap works again.\n\n\n    CodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\"))) cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) {\n        return undefined;\n      }\n\n      if (this[key]) {\n        return this[key];\n      }\n\n      var vimKey = cmKeyToVimKey(key);\n\n      if (!vimKey) {\n        return false;\n      }\n\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n\n      return cmd;\n    }\n\n    var modifiers = {\n      'Shift': 'S',\n      'Ctrl': 'C',\n      'Alt': 'A',\n      'Cmd': 'D',\n      'Mod': 'A'\n    };\n    var specialKeys = {\n      Enter: 'CR',\n      Backspace: 'BS',\n      Delete: 'Del',\n      Insert: 'Ins'\n    };\n\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n\n      var hasCharacter = false;\n\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n\n        if (piece in modifiers) {\n          pieces[i] = modifiers[piece];\n        } else {\n          hasCharacter = true;\n        }\n\n        if (piece in specialKeys) {\n          pieces[i] = specialKeys[piece];\n        }\n      }\n\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      } // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n\n\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function () {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }],\n        bigWordCharTest = [function (ch) {\n      return /\\S/.test(ch);\n    }];\n\n    function makeKeyRange(start, size) {\n      var keys = [];\n\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n\n      return keys;\n    }\n\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n\n    function isLowerCase(k) {\n      return /^[a-z]$/.test(k);\n    }\n\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n\n    function isUpperCase(k) {\n      return /^[A-Z]$/.test(k);\n    }\n\n    function isWhiteSpaceString(k) {\n      return /^\\s*$/.test(k);\n    }\n\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    var options = {};\n\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n\n      if (!type) {\n        type = 'string';\n      }\n\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {\n            value: value\n          };\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n\n        if (scope !== 'local') {\n          return option.callback();\n        }\n\n        return;\n      } else {\n        var local = scope !== 'global' && cm && cm.state.vim.options[name];\n        return (local || scope !== 'local' && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      } // The 'filetype' option proxies to the CodeMirror 'mode' option.\n\n\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function createCircularJumpList() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n\n          if (trashMark) {\n            trashMark.clear();\n          }\n\n          buffer[next] = cm.setBookmark(cursor);\n        }\n\n        if (curMark) {\n          var markPos = curMark.find(); // avoid recording redundant cursor position\n\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n\n      function move(cm, offset) {\n        pointer += offset;\n\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n\n        var mark = buffer[(size + pointer) % size]; // skip marks that are temporarily removed from text buffer\n\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size]; // skip marks that are the same as current position\n\n            if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n\n        return mark;\n      }\n\n      return {\n        cachedCursor: undefined,\n        //used for # and * jumps\n        add: add,\n        move: move\n      };\n    }; // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n\n\n    var createInsertModeChanges = function createInsertModeChanges(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function exitMacroRecordMode() {\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function enterMacroRecordMode(cm, registerName) {\n        var register = vimGlobalState.registerController.getRegister(registerName);\n\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog('(recording)[' + registerName + ']', null, {\n              bottom: true\n            });\n          }\n\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n\n      return cm.state.vim;\n    }\n\n    var vimGlobalState;\n\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState(),\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {\n          increment: 0,\n          forward: true,\n          selectedCharacter: ''\n        },\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController: new HistoryController()\n      };\n\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      buildKeyMap: function buildKeyMap() {// TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function getRegisterController() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n      // Testing hook.\n      getVimGlobalState_: function getVimGlobalState_() {\n        return vimGlobalState;\n      },\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n      suppressErrorLogging: false,\n      InsertModeKey: InsertModeKey,\n      map: function map(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function unmap(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function defineEx(name, prefix, func) {\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n        }\n\n        exCommands[name] = func;\n        exCommandDispatcher.commandMap_[prefix] = {\n          name: name,\n          shortName: prefix,\n          type: 'api'\n        };\n      },\n      handleKey: function handleKey(cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function findKey(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n\n            return true;\n          }\n        }\n\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) {\n            return true;\n          }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert'); // Need to check all key substrings in insert mode.\n\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n\n            if (thisMatch.type != 'none') {\n              match = thisMatch;\n            }\n          }\n\n          if (match.type == 'none') {\n            clearInputState(cm);\n            return false;\n          } else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) {\n              window.clearTimeout(lastInsertModeKeyTimer);\n            }\n\n            lastInsertModeKeyTimer = window.setTimeout(function () {\n              if (vim.insertMode && vim.inputState.keyBuffer) {\n                clearInputState(cm);\n              }\n            }, getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) {\n            return true;\n          }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n\n          if (/^[1-9]\\d*$/.test(keys)) {\n            return true;\n          }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n          if (!keysMatcher) {\n            clearInputState(cm);\n            return false;\n          }\n\n          var context = vim.visualMode ? 'visual' : 'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n\n          if (match.type == 'none') {\n            clearInputState(cm);\n            return false;\n          } else if (match.type == 'partial') {\n            return true;\n          }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n\n          return match.command;\n        }\n\n        var command;\n\n        if (vim.insertMode) {\n          command = handleKeyInsertMode();\n        } else {\n          command = handleKeyNonInsertMode();\n        }\n\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function () {\n            return true;\n          } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function () {\n            return true;\n          };\n        } else {\n          return function () {\n            return cm.operation(function () {\n              cm.curOp.isVimOp = true;\n\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n\n                throw e;\n              }\n\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function handleEx(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n      defineRegister: defineRegister,\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    }; // Represents the current input state.\n\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n\n    InputState.prototype.pushRepeatDigit = function (n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n\n    InputState.prototype.getRepeat = function () {\n      var repeat = 0;\n\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n\n\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n\n    Register.prototype = {\n      setText: function setText(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function pushText(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n\n          this.linewise = true;\n        }\n\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function pushInsertModeChanges(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function pushSearchQuery(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function clear() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function toString() {\n        return this.keyBuffer.join('');\n      }\n    };\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n\n\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n\n    RegisterController.prototype = {\n      pushText: function pushText(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n') {\n          text += '\\n';\n        } // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n\n\n        var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null; // if no register/an invalid register was specified, things go to the\n        // default registers\n\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n\n              break;\n          } // Make sure the unnamed register is set to what just happened\n\n\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        } // If we've gotten to this point, we've actually specified a register\n\n\n        var append = isUpperCase(registerName);\n\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        } // The unnamed register always has the same value as the last used\n        // register.\n\n\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function getRegister(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n\n        name = name.toLowerCase();\n\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n\n        return this.registers[name];\n      },\n      isValidRegister: function isValidRegister(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function shiftNumericRegisters_() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n\n    function HistoryController() {\n      this.historyBuffer = [];\n      this.iterator = 0;\n      this.initialPrefix = null;\n    }\n\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function nextMatch(input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n          var element = historyBuffer[i];\n\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        } // should return the user input in case we reach the end of buffer.\n\n\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        } // return the last autocompleted query or exCommand as it is.\n\n\n        if (i < 0) return input;\n      },\n      pushInput: function pushInput(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function reset() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function matchCommand(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n\n        if (!matches.full && !matches.partial) {\n          return {\n            type: 'none'\n          };\n        } else if (!matches.full && matches.partial) {\n          return {\n            type: 'partial'\n          };\n        }\n\n        var bestMatch;\n\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {\n            type: 'none'\n          };\n          inputState.selectedCharacter = character;\n        }\n\n        return {\n          type: 'full',\n          command: bestMatch\n        };\n      },\n      processCommand: function processCommand(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n\n          default:\n            break;\n        }\n      },\n      processMotion: function processMotion(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function processOperator(cm, vim, command) {\n        var inputState = vim.inputState;\n\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = {\n              linewise: true\n            };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function processOperatorMotion(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n\n        this.processOperator(cm, vim, command);\n\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function processAction(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        } // Actions may or may not have motions and operators. Do these first.\n\n\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function processSearch(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = forward ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: {\n              forward: true,\n              toJumplist: command.searchArgs.toJumplist\n            }\n          });\n        }\n\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n          var macroModeState = vimGlobalState.macroModeState;\n\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e),\n              up,\n              offset;\n\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.searchHistoryController.reset();\n          }\n\n          var parsedQuery;\n\n          try {\n            parsedQuery = updateSearchQuery(cm, query, true\n            /** ignoreCase */\n            , true\n            /** smartCase */\n            );\n          } catch (e) {// Swallow bad regexes for incremental search.\n          }\n\n          if (parsedQuery) {\n            cm.scrollIntoView(_findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && query == '') {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true\n              /** ignoreCase */\n              , false\n              /** smartCase */\n              );\n            } else {\n              showPrompt(cm, {\n                onClose: onPromptClose,\n                prefix: promptPrefix,\n                desc: searchPromptDesc,\n                onKeyUp: onPromptKeyUp,\n                onKeyDown: onPromptKeyDown\n              });\n            }\n\n            break;\n\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false\n            /** inclusive */\n            , true\n            /** forward */\n            , false\n            /** bigWord */\n            , true\n            /** noSymbol */\n            );\n            var isKeyword = true;\n\n            if (!word) {\n              word = expandWordUnderCursor(cm, false\n              /** inclusive */\n              , true\n              /** forward */\n              , false\n              /** bigWord */\n              , false\n              /** noSymbol */\n              );\n              isKeyword = false;\n            }\n\n            if (!word) {\n              return;\n            }\n\n            var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n\n            if (isKeyword && wholeWordOnly) {\n              query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            } // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n\n\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n            handleQuery(query, true\n            /** ignoreCase */\n            , false\n            /** smartCase */\n            );\n            break;\n        }\n      },\n      processEx: function processEx(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e),\n              up,\n              offset;\n\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && input == '') {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: ':',\n              value: '\\'<,\\'>',\n              onKeyDown: onPromptKeyDown,\n              selectValueOnOpen: false\n            });\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: ':',\n              onKeyDown: onPromptKeyDown\n            });\n          }\n        }\n      },\n      evalInput: function evalInput(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel; // TODO: Make sure cm and vim selections are identical outside visual mode.\n\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n\n          if (!motionResult) {\n            return;\n          }\n\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList; // if the current motion is # or *, use cachedCursor\n\n            var cachedCursor = jumpList.cachedCursor;\n\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          } // TODO: Handle null returns from motion commands better.\n\n\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n            updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n\n            if (linewise) {\n              var ranges = cmSel.ranges;\n\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n\n          operatorArgs.registerName = registerName; // Keep track of linewise as it affects how paste and change behave.\n\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function recordLastEdit(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isPlaying) {\n          return;\n        }\n\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      }\n    };\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n\n    var motions = {\n      moveToTopLine: function moveToTopLine(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function moveToMiddleLine(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function moveToBottomLine(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function expandToLine(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function findNext(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward; // If search is initiated with ? instead of /, negate direction.\n\n        prev = state.isReversed() ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return _findNext(cm, prev\n        /** prev */\n        , query, motionArgs.repeat);\n      },\n      goToMark: function goToMark(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n\n        if (pos) {\n          return motionArgs.linewise ? {\n            line: pos.line,\n            ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n          } : pos;\n        }\n\n        return null;\n      },\n      moveToOtherHighlightedEnd: function moveToOtherHighlightedEnd(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))];\n        } else {\n          return [vim.sel.head, vim.sel.anchor];\n        }\n      },\n      jumpToMark: function jumpToMark(cm, head, motionArgs, vim) {\n        var best = head;\n\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n\n            var mark = vim.marks[key].find();\n            var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n\n            if (motionArgs.linewise && mark.line == cursor.line) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n\n        return best;\n      },\n      moveByCharacters: function moveByCharacters(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function moveByLines(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch; // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n\n          default:\n            vim.lastHPos = endCh;\n        }\n\n        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine(); // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n\n        if (line < first && cur.line == first) {\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last) {\n          return this.moveToEol(cm, head, motionArgs, vim);\n        }\n\n        if (motionArgs.toFirstChar) {\n          endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh), 'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function moveByDisplayLines(cm, head, motionArgs, vim) {\n        var cur = head;\n\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n\n          default:\n            vim.lastHSPos = cm.charCoords(cur, 'div').left;\n        }\n\n        var repeat = motionArgs.repeat;\n        var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = {\n              top: lastCharCoords.top + 8,\n              left: vim.lastHSPos\n            };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function moveByPage(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n      },\n      moveByParagraph: function moveByParagraph(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function moveBySentence(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function moveByScroll(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n\n        if (!curEnd) {\n          return null;\n        }\n\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function moveByWords(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function moveTillCharacter(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n\n        var curEnd = _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function moveToCharacter(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function moveToSymbol(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function moveToColumn(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat; // repeat is equivalent to which column we want to move to!\n\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head, 'div').left;\n        return _moveToColumn(cm, repeat);\n      },\n      moveToEol: function moveToEol(cm, head, motionArgs, vim) {\n        var cur = head;\n        vim.lastHPos = Infinity;\n        var retval = Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end = cm.clipPos(retval);\n        end.ch--;\n        vim.lastHSPos = cm.charCoords(end, 'div').left;\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function moveToFirstNonWhiteSpaceCharacter(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function moveToMatchedSymbol(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n\n        if (ch < lineText.length) {\n          var matched = cm.findMatchingBracket(Pos(line, ch));\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function moveToStartOfLine(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function moveToLineOrEdgeOfDocument(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n\n        return Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function textObjectManipulation(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        // TODO: adding <> >< to this map doesn't work, presumably because\n        // they're operators\n        var mirroredPairs = {\n          '(': ')',\n          ')': '(',\n          '{': '}',\n          '}': '{',\n          '[': ']',\n          ']': '['\n        };\n        var selfPaired = {\n          '\\'': true,\n          '\"': true\n        };\n        var character = motionArgs.selectedCharacter; // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        } // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n\n\n        var inclusive = !motionArgs.textObjectInner;\n        var tmp;\n\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true\n          /** forward */\n          , true\n          /** bigWord */\n          );\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true\n          /** forward */\n          , false\n          /** bigWord */\n          );\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n\n          if (vim.visualMode) {\n            if (!vim.visualLine) {\n              vim.visualLine = true;\n            }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n\n            if (operatorArgs) {\n              operatorArgs.linewise = true;\n            }\n\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n      repeatLastCharacterSearch: function repeatLastCharacterSearch(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n\n        var curEnd = _moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n\n\n    var operators = {\n      change: function change(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\n\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = /\\s+$/.exec(text);\n\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, -match[0].length);\n              text = text.slice(0, -match[0].length);\n            }\n          }\n\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            } // make sure cursor ends up at the end of the line.\n\n\n            anchor.ch = Number.MAX_VALUE;\n          }\n\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n\n        vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {\n          head: finalHead\n        }, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function _delete(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n\n          if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n\n        vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n        var includeLineBreak = vim.insertMode;\n        return clipCursorToContent(cm, finalHead, includeLineBreak);\n      },\n      indent: function indent(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line; // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n\n        var repeat = vim.visualMode ? args.repeat : 1;\n\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function changeCase(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n            }\n          }\n\n          swapped.push(text);\n        }\n\n        cm.replaceSelections(swapped);\n\n        if (args.shouldMoveCursor) {\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise) {\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function yank(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n        vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function jumpListWalk(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function scroll(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n            cursor.line += (newPos - cursorCoords.top) / lineHeight;\n            cursor.line = Math.ceil(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(null, cursorCoords.top);\n          } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n\n          if (newBottom < cursorCoords.bottom) {\n            cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n            cursor.line = Math.floor(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function scrollToCursor(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n\n        switch (actionArgs.position) {\n          case 'center':\n            y = y - height / 2 + lineHeight;\n            break;\n\n          case 'bottom':\n            y = y - height + lineHeight;\n            break;\n        }\n\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function replayMacro(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        }\n\n        while (repeat--) {\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function enterMacroRecordMode(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function toggleOverwrite(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"replace\"\n          });\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"insert\"\n          });\n        }\n      },\n      enterInsertMode: function enterInsertMode(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) {\n          return;\n        }\n\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = actionArgs ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode) {\n            return;\n          }\n        }\n\n        cm.setOption('disableInput', false);\n\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"replace\"\n          });\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"insert\"\n          });\n        }\n\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function toggleVisualMode(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head; // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(cm, Pos(anchor.line, anchor.ch + repeat - 1), true\n          /** includeLineBreak */\n          );\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n          });\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n          });\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function reselectLastSelection(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n          });\n        }\n      },\n      joinLines: function joinLines(cm, actionArgs, vim) {\n        var curStart, curEnd;\n\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1, Infinity));\n        }\n\n        var finalCh = 0;\n\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n\n        var curFinalPos = Pos(curStart.line, finalCh);\n\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function newLineAndEnterInsertMode(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n\n        this.enterInsertMode(cm, {\n          repeat: actionArgs.repeat\n        }, vim);\n      },\n      paste: function paste(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n        var text = register.toString();\n\n        if (!text) {\n          return;\n        }\n\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\"); // length that considers tabs and tabSize\n\n          var whitespaceLength = function whitespaceLength(str) {\n            var tabs = str.split(\"\\t\").length - 1;\n            var spaces = str.split(\" \").length - 1;\n            return tabs * tabSize + spaces * 1;\n          };\n\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]); // chomp last newline b/c don't want it to match /^\\s*/gm\n\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n\n            if (newIndent < 0) {\n              return \"\";\n            } else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            } else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n\n        if (linewise) {\n          if (vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            text = text.split('\\n');\n\n            for (var i = 0; i < text.length; i++) {\n              text[i] = text[i] == '' ? ' ' : text[i];\n            }\n          }\n\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n\n        var curPosFinal;\n        var idx;\n\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1'); // save the curEnd marker before it get cleared due to cm.replaceRange.\n\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          } // push the previously selected text to unnamed register\n\n\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings); // Set new selections as per the block length of the yanked text\n\n            selectionEnd = Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          } // restore the the curEnd marker\n\n\n          if (lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n\n          if (linewise) {\n            curPosFinal.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line + i;\n\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n', Pos(line, 0));\n              }\n\n              var lastCh = lineLength(cm, line);\n\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length - 1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur); // Now fine tune the cursor to where we want it.\n\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n\n        cm.setCursor(curPosFinal);\n      },\n      undo: function undo(cm, actionArgs) {\n        cm.operation(function () {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function redo(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function setRegister(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function setMark(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function replace(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n\n          if (replaceTo > line.length) {\n            replaceTo = line.length;\n          }\n\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n\n        if (replaceWith == '\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd); // special case, where vim help says to replace by just one line-break\n\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd); //replace all characters in range by selected, but keep linebreaks\n\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function incrementNumberToken(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end) break;\n        }\n\n        if (!actionArgs.backtrack && end <= cur.ch) return;\n\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {\n            '0b': 2,\n            '0': 8,\n            '': 10,\n            '0x': 16\n          }[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function repeatLastEdit(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n\n        if (!lastEditInputState) {\n          return;\n        }\n\n        var repeat = actionArgs.repeat;\n\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n\n        _repeatLastEdit(cm, vim, repeat, false\n        /** repeatForInsert */\n        );\n      },\n      indent: function indent(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n\n\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = includeLineBreak ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n\n    function copyArgs(args) {\n      var ret = {};\n\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n\n      return ret;\n    }\n\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n\n    function getOffset(anchor, head) {\n      return {\n        line: head.line - anchor.line,\n        ch: head.line - anchor.line\n      };\n    }\n\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match,\n          partial = [],\n          full = [];\n\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n\n        if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n          continue;\n        }\n\n        if (match == 'partial') {\n          partial.push(command);\n        }\n\n        if (match == 'full') {\n          full.push(command);\n        }\n      }\n\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n\n      if (selectedCharacter.length > 1) {\n        switch (selectedCharacter) {\n          case '<CR>':\n            selectedCharacter = '\\n';\n            break;\n\n          case '<Space>':\n            selectedCharacter = ' ';\n            break;\n\n          default:\n            selectedCharacter = '';\n            break;\n        }\n      }\n\n      return selectedCharacter;\n    }\n\n    function repeatFn(cm, fn, repeat) {\n      return function () {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column - endCh + 1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    } // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n\n\n    function selectBlock(cm, selectionEnd) {\n      var selections = [],\n          ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch,\n          headCh = head.ch;\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n\n        if (!isClipped) {\n          headCh--;\n        }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n\n        if (!wasClipped) {\n          headCh++;\n        }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {\n          anchor: new Pos(line, baseCh),\n          head: new Pos(line, headCh)\n        };\n        selections.push(range);\n      }\n\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({\n          anchor: lineHead,\n          head: lineHead\n        });\n      }\n\n      cm.setSelections(sel, 0);\n    } // getIndex returns the index of the cursor in the selections.\n\n\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n\n      var getCurrentSelectedAreaRange = function getCurrentSelectedAreaRange() {\n        var selections = cm.listSelections();\n        var start = selections[0];\n        var end = selections[selections.length - 1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n\n      var getLastSelectedAreaRange = function getLastSelectedAreaRange() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = []; // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {\n              anchor: anchor,\n              head: head\n            };\n            selections.push(range);\n          }\n\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {\n            line: selectionEnd.line + line,\n            ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n          };\n\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n\n        return [selectionStart, selectionEnd];\n      };\n\n      if (!vim.visualMode) {\n        // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    } // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n\n\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head; // To accommodate the effect of lastPastedText in the last selection\n\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n\n      vim.lastSelection = {\n        'anchorMark': cm.setBookmark(anchor),\n        'headMark': cm.setBookmark(head),\n        'anchor': copyCursor(anchor),\n        'head': copyCursor(head),\n        'visualMode': vim.visualMode,\n        'visualLine': vim.visualLine,\n        'visualBlock': vim.visualBlock\n      };\n    }\n\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n\n\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{\n            anchor: anchor,\n            head: head\n          }],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n          var lastLine = cm.lastLine();\n\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n\n        return {\n          ranges: [{\n            anchor: anchor,\n            head: head\n          }],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n\n      return cur;\n    }\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n\n\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    } // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n\n\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd); // Only clip if the selection ends with trailing newline + whitespace\n\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n'); // We know this is all whitespace.\n\n        lines.pop(); // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n\n        var line; // Find the line containing the last word, and clip all whitespace up\n        // to it.\n\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        } // If the last word is not an empty line, clip an additional newline\n\n\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    } // Expand the selection to line ends.\n\n\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch; // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n\n      while (!test(line.charAt(idx))) {\n        idx++;\n\n        if (idx >= line.length) {\n          return null;\n        }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx,\n          start = idx;\n\n      while (test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n\n      while (test(line.charAt(start)) && start >= 0) {\n        start--;\n      }\n\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n\n        while (/\\s/.test(line.charAt(end)) && end < line.length) {\n          end++;\n        }\n\n        if (wordEnd == end) {\n          var wordStart = start;\n\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n            start--;\n          }\n\n          if (!start) {\n            start = wordStart;\n          }\n        }\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n      vimGlobalState.lastCharacterSearch.increment = increment;\n      vimGlobalState.lastCharacterSearch.forward = args.forward;\n      vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n      '(': 'bracket',\n      ')': 'bracket',\n      '{': 'bracket',\n      '}': 'bracket',\n      '[': 'section',\n      ']': 'section',\n      '*': 'comment',\n      '/': 'comment',\n      'm': 'method',\n      'M': 'method',\n      '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function isComplete(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1) return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n\n          return false;\n        }\n      },\n      section: {\n        init: function init(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function isComplete(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function isComplete(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function init(state) {\n          state.symb = state.symb === 'm' ? '{' : '}';\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function isComplete(state) {\n          if (state.nextCh === state.symb) return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function init(state) {\n          state.index = 0;\n        },\n        isComplete: function isComplete(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n\n              state.depth--;\n            }\n\n            if (token === 'else' && state.depth === 0) return true;\n          }\n\n          return false;\n        }\n      }\n    };\n\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ? {\n          ')': '(',\n          '}': '{'\n        } : {\n          '(': ')',\n          '{': '}'\n        })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode) return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n\n      if (init) {\n        init(state);\n      }\n\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = lineLen > 0 ? lineLen - 1 : 0;\n          }\n\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n\n      return cur;\n    }\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n\n\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest : wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n\n        pos = forward ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return {\n            from: 0,\n            to: 0,\n            line: lineNum\n          };\n        }\n\n        var stop = dir > 0 ? line.length : -1;\n        var wordStart = stop,\n            wordEnd = stop; // Find bounds of next word.\n\n        while (pos != stop) {\n          var foundWord = false;\n\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos; // Advance to end of word.\n\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n\n              if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum\n                };\n              }\n            }\n          }\n\n          if (!foundWord) {\n            pos += dir;\n          }\n        } // Advance to next/prev line.\n\n\n        lineNum += dir;\n\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n\n        line = cm.getLine(lineNum);\n        pos = dir > 0 ? 0 : line.length;\n      }\n    }\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n\n\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      } // For 'e', empty lines are not considered words, go figure.\n\n\n      var emptyLineIsWord = !(forward && wordEnd);\n\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward ? {\n            line: cm.lastLine(),\n            from: eodCh,\n            to: eodCh\n          } : {\n            line: 0,\n            from: 0,\n            to: 0\n          });\n          break;\n        }\n\n        words.push(word);\n        cur = Pos(word.line, forward ? word.to - 1 : word.from);\n      }\n\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function _moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n\n      for (var i = 0; i < repeat; i++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n\n        if (idx == -1) {\n          return null;\n        }\n\n        start = idx;\n      }\n\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function _moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start,\n          end,\n          i = line;\n\n      function isEmpty(i) {\n        return !cm.getLine(i);\n      }\n\n      function isBoundary(i, dir, any) {\n        if (any) {\n          return isEmpty(i) != isEmpty(i + dir);\n        }\n\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) {\n            repeat--;\n          }\n\n          i += dir;\n        }\n\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n\n      var startState = isEmpty(line);\n\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n\n      end = new Pos(i, 0); // select boundary before paragraph for the last one\n\n      if (i > max && !startState) {\n        startState = true;\n      } else {\n        inclusive = false;\n      }\n\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) {\n            break;\n          }\n        }\n      }\n\n      start = new Pos(i, 0);\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n        } else {\n          idx.pos += idx.dir;\n        }\n      }\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n\n\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = line === \"\";\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir\n        };\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n        var skip_empty_lines = curr.line === \"\"; // Move one step to skip character we start on\n\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n\n\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n\n        for (var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n      }\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n\n\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir\n        };\n        var last_valid = {\n          ln: curr.ln,\n          pos: null\n        };\n        var skip_empty_lines = curr.line === \"\"; // Move one step to skip character we start on\n\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            } else {\n              return {\n                ln: curr.ln,\n                pos: curr.pos\n              };\n            }\n          } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n\n          nextChar(cm, curr);\n        }\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n\n\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n\n        for (var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        } else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n\n        repeat--;\n      }\n\n      return Pos(curr_index.ln, curr_index.pos);\n    } // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n\n\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head,\n          start,\n          end;\n      var bracketRegexp = {\n        '(': /[()]/,\n        ')': /[()]/,\n        '[': /[[\\]]/,\n        ']': /[[\\]]/,\n        '{': /[{}]/,\n        '}': /[{}]/\n      }[symb];\n      var openSym = {\n        '(': '(',\n        ')': '(',\n        '[': '[',\n        ']': '[',\n        '{': '{',\n        '}': '{'\n      }[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch); // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n\n      var offset = curChar === openSym ? 1 : 0;\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {\n        'bracketRegex': bracketRegexp\n      });\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {\n        'bracketRegex': bracketRegexp\n      });\n\n      if (!start || !end) {\n        return {\n          start: cur,\n          end: cur\n        };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return {\n        start: start,\n        end: end\n      };\n    } // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n\n\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb); // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex; // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      } // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n\n        --cur.ch; // make sure to look backwards\n      } // if we're currently on the symbol, we've got a start\n\n\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      } // look forwards for the end symbol\n\n\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      } // nothing found\n\n\n      if (!start || !end) {\n        return {\n          start: cur,\n          end: cur\n        };\n      } // include the symbols\n\n\n      if (inclusive) {\n        --start;\n        ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    } // Search functions\n\n\n    defineOption('pcre', true, 'boolean');\n\n    function SearchState() {}\n\n    SearchState.prototype = {\n      getQuery: function getQuery() {\n        return vimGlobalState.query;\n      },\n      setQuery: function setQuery(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function getOverlay() {\n        return this.searchOverlay;\n      },\n      setOverlay: function setOverlay(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function isReversed() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function setReversed(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function getScrollbarAnnotate() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function setScrollbarAnnotate(annotate) {\n        this.annotate = annotate;\n      }\n    };\n\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, {\n          bottom: true,\n          value: options.value,\n          onKeyDown: options.onKeyDown,\n          onKeyUp: options.onKeyUp,\n          selectValueOnOpen: false\n        });\n      } else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = []; // in case of strings like foo/bar\n\n      if (slashes[0] !== 0) return;\n\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n      }\n\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator) separator = '/';\n      var escapeNextChar = false;\n      var slashes = [];\n\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n\n        escapeNextChar = !escapeNextChar && c == '\\\\';\n      }\n\n      return slashes;\n    } // Translates a search string from ex (vim) syntax into javascript form.\n\n\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){'; // Remove, but never add, a '\\' for these.\n\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        var specialComesNext = n && specials.indexOf(n) != -1;\n\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true; // Treat the unescape list as special for removing, but not adding '\\'.\n\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            } // Not passing this test means removing a '\\'.\n\n\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n\n      return out.join('');\n    } // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n\n\n    var charUnescapes = {\n      '\\\\n': '\\n',\n      '\\\\r': '\\r',\n      '\\\\t': '\\t'\n    };\n\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c + n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n\n            if (isNumber(n) || n === '$') {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n\n            out.push(c);\n\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n\n      return out.join('');\n    } // Unescape \\ and / in the replace part, for PCRE mode.\n\n\n    var unescapes = {\n      '\\\\/': '/',\n      '\\\\\\\\': '\\\\',\n      '\\\\n': '\\n',\n      '\\\\r': '\\r',\n      '\\\\t': '\\t'\n    };\n\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n\n        var matched = false;\n\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n\n      return output.join('');\n    }\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n\n\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query); // Check if the query is already a regex.\n\n      if (query instanceof RegExp) {\n        return query;\n      } // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n\n\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = flagsPart.indexOf('i') != -1;\n      }\n\n      if (!regexPart) {\n        return null;\n      }\n\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n\n      if (smartCase) {\n        ignoreCase = /^[^A-Z]*$/.test(regexPart);\n      }\n\n      var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'i' : undefined);\n      return regexp;\n    }\n\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>', {\n          bottom: true,\n          duration: 5000\n        });\n      } else {\n        alert(text);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' + (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc) raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n\n    var searchPromptDesc = '(Javascript regexp)';\n\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n        var props = ['global', 'multiline', 'ignoreCase', 'source'];\n\n        for (var i = 0; i < props.length; i++) {\n          var prop = props[i];\n\n          if (r1[prop] !== r2[prop]) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    } // Returns true if the query is valid.\n\n\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n\n      if (!query) {\n        return;\n      }\n\n      highlightSearchMatches(cm, query);\n\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n\n      state.setQuery(query);\n      return query;\n    }\n\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n\n      return {\n        token: function token(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n\n          var match = stream.match(query, false);\n\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n\n            stream.match(query);\n            return 'searching';\n          }\n\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n\n        searchState.setOverlay(overlay);\n      }\n    }\n\n    function _findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) {\n        repeat = 1;\n      }\n\n      return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            found = cursor.find(prev);\n          }\n\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query, prev ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0));\n\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n\n        return cursor.from();\n      });\n    }\n\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n\n\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return pos >= start && pos <= end;\n        } else {\n          return pos == start;\n        }\n      }\n    }\n\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({\n        left: 0,\n        top: occludeToleranceTop + scrollInfo.top\n      }, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({\n        left: 0,\n        top: bottomY\n      }, 'local');\n      return {\n        top: from.line,\n        bottom: to.line\n      };\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done;\n        var event = history[history.length - 2];\n        return event && event.ranges && event.ranges[0].head;\n      } else if (markName == '.') {\n        if (cm.doc.history.lastModTime == 0) {\n          return; // If no changes, bail out; don't bother to copy or reverse history array.\n        } else {\n          var changeHistory = cm.doc.history.done.filter(function (el) {\n            if (el.changes !== undefined) {\n              return el;\n            }\n          });\n          changeHistory.reverse();\n          var lastEditPos = changeHistory[0].changes[0].to;\n        }\n\n        return lastEditPos;\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    var ExCommandDispatcher = function ExCommandDispatcher() {\n      this.buildCommandMap_();\n    };\n\n    ExCommandDispatcher.prototype = {\n      processCommand: function processCommand(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function _processCommand(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n\n        var inputStream = new CodeMirror.StringStream(input); // update \": with the latest command whether valid or invalid\n\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch (e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n\n        var command;\n        var commandName;\n\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n\n          if (command) {\n            commandName = command.name;\n\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n\n            this.parseCommandArgs_(inputStream, params, command);\n\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n\n        try {\n          exCommands[commandName](cm, params); // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch (e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function parseInput_(cm, inputStream, result) {\n        inputStream.eatWhile(':'); // Parse range.\n\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        } // Parse command name.\n\n\n        var commandMatch = inputStream.match(/^(\\w+)/);\n\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function parseLineSpec_(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n\n          case '-':\n          case '+':\n            inputStream.backUp(1); // Offset is relative to current line if not otherwise specified.\n\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function parseLineSpecOffset_(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n\n        return line;\n      },\n      parseCommandArgs_: function parseCommandArgs_(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n\n        params.argString = inputStream.match(/.*/)[0]; // Parse command-line arguments\n\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function matchCommand_(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n\n        return null;\n      },\n      buildCommandMap_: function buildCommandMap_() {\n        this.commandMap_ = {};\n\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function map(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) {\n            throw Error('Mode not supported for ex mappings');\n          }\n\n          var commandName = lhs.substring(1);\n\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: {\n                input: rhs.substring(1)\n              }\n            };\n\n            if (ctx) {\n              mapping.context = ctx;\n            }\n\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n\n            if (ctx) {\n              mapping.context = ctx;\n            }\n\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function unmap(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) {\n            throw Error('Mode not supported for ex mappings');\n          }\n\n          var commandName = lhs.substring(1);\n\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n\n        throw Error('No such mapping.');\n      }\n    };\n    var exCommands = {\n      colorscheme: function colorscheme(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function map(cm, params, ctx) {\n        var mapArgs = params.args;\n\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n\n          return;\n        }\n\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function imap(cm, params) {\n        this.map(cm, params, 'insert');\n      },\n      nmap: function nmap(cm, params) {\n        this.map(cm, params, 'normal');\n      },\n      vmap: function vmap(cm, params) {\n        this.map(cm, params, 'visual');\n      },\n      unmap: function unmap(cm, params, ctx) {\n        var mapArgs = params.args;\n\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n\n          return;\n        }\n\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function move(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n          type: 'motion',\n          motion: 'moveToLineOrEdgeOfDocument',\n          motionArgs: {\n            forward: false,\n            explicitRepeat: true,\n            linewise: true\n          },\n          repeatOverride: params.line + 1\n        });\n      },\n      set: function set(cm, params) {\n        var setArgs = params.args; // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n\n        var setCfg = params.setCfg || {};\n\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n\n          return;\n        }\n\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) {\n            throw Error('Trailing characters: ' + params.argString);\n          }\n\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        } // If no value is provided, then we assume this is a get.\n\n\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function setlocal(cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {\n          scope: 'local'\n        };\n        this.set(cm, params);\n      },\n      setglobal: function setglobal(cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {\n          scope: 'global'\n        };\n        this.set(cm, params);\n      },\n      registers: function registers(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n\n        showConfirm(cm, regInfo);\n      },\n      sort: function sort(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n\n            if (args.eat('!')) {\n              reverse = true;\n            }\n\n            if (args.eol()) {\n              return;\n            }\n\n            if (!args.eatSpace()) {\n              return 'Invalid arguments';\n            }\n\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n\n            if (!opts && !args.eol()) {\n              return 'Invalid arguments';\n            }\n\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n\n              if (decimal + hex + octal > 1) {\n                return 'Invalid arguments';\n              }\n\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n\n        var err = parseArgs();\n\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n\n        if (lineStart == lineEnd) {\n          return;\n        }\n\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n        var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n        var numPart = [],\n            textPart = [];\n\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n\n        function compareFn(a, b) {\n          if (reverse) {\n            var tmp;\n            tmp = a;\n            a = b;\n            b = tmp;\n          }\n\n          if (ignoreCase) {\n            a = a.toLowerCase();\n            b = b.toLowerCase();\n          }\n\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n\n          if (!anum) {\n            return a < b ? -1 : 1;\n          }\n\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n\n        function comparePatternFn(a, b) {\n          if (reverse) {\n            var tmp;\n            tmp = a;\n            a = b;\n            b = tmp;\n          }\n\n          if (ignoreCase) {\n            a[0] = a[0].toLowerCase();\n            b[0] = b[0].toLowerCase();\n          }\n\n          return a[0] < b[0] ? -1 : 1;\n        }\n\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) {\n          textPart.sort(compareFn);\n        }\n\n        text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n\n        if (unique) {\n          // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n\n            lastLine = textOld[i];\n          }\n        }\n\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function global(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        } // range is specified here\n\n\n        var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine(); // get the tokens from argString\n\n        var tokens = splitBySlash(argString);\n        var regexPart = argString,\n            cmd;\n\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true\n            /** ignoreCase */\n            , true\n            /** smartCase */\n            );\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        } // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n\n\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [],\n            content = '';\n\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n\n          if (matched) {\n            matchedLines.push(i + 1);\n            content += cm.getLine(i) + '<br>';\n          }\n        } // if there is no [cmd], just display the list of matched lines\n\n\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n\n        var index = 0;\n\n        var nextCommand = function nextCommand() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n\n          index++;\n        };\n\n        nextCommand();\n      },\n      substitute: function substitute(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n        }\n\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart,\n            replacePart = '',\n            trailing,\n            flagsPart,\n            count;\n        var confirm = false; // Whether to confirm each replace.\n\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n\n        if (tokens.length) {\n          regexPart = tokens[0];\n          replacePart = tokens[1];\n\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart);\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n            return;\n          }\n        } // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n\n\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true\n            /** ignoreCase */\n            , true\n            /** smartCase */\n            );\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function write(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function nohlsearch(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function yank(cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n      },\n      delmarks: function delmarks(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n\n        while (!stream.eol()) {\n          stream.eatSpace(); // Record the streams position at the beginning of the loop for use\n          // in error messages.\n\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next(); // Check if this symbol is part of a range\n\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next(); // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n\n            if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              } // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n\n\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n    var exCommandDispatcher = new ExCommandDispatcher();\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n\n      function replaceAll() {\n        cm.operation(function () {\n          while (!done) {\n            replace();\n            next();\n          }\n\n          stop();\n        });\n      }\n\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while (searchCursor.findNext() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n\n        done = true;\n      }\n\n      function stop(close) {\n        if (close) {\n          close();\n        }\n\n        cm.focus();\n\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n\n        if (callback) {\n          callback();\n        }\n      }\n\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n\n        switch (keyName) {\n          case 'Y':\n            replace();\n            next();\n            break;\n\n          case 'N':\n            next();\n            break;\n\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n\n          case 'L':\n            replace();\n          // fall through and exit.\n\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n\n        if (done) {\n          stop(close);\n        }\n\n        return true;\n      } // Actually do replace.\n\n\n      next();\n\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n\n      if (!confirm) {\n        replaceAll();\n\n        if (callback) {\n          callback();\n        }\n\n        return;\n      }\n\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges; // In case of visual block, the insertModeChanges are not saved as a\n      // single word, so we convert them to a single word\n      // so as to update the \". register as expected in real vim.\n\n      var text = [];\n\n      if (!isPlaying) {\n        var selLength = lastChange.inVisualBlock && vim.lastSelection ? vim.lastSelection.visualBlock.height : 1;\n        var changes = lastChange.changes;\n        var text = [];\n        var i = 0; // In case of multiple selections in blockwise visual,\n        // the inserted text, for example: 'f<Backspace>oo', is stored as\n        // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n        // We push the contents of the changes array as per the following:\n        // 1. In case of InsertModeKey, just increment by 1.\n        // 2. In case of a character, jump by selLength (2 in the example).\n\n        while (i < changes.length) {\n          // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n          text.push(changes[i]);\n\n          if (changes[i] instanceof InsertModeKey) {\n            i++;\n          } else {\n            i += selLength;\n          }\n        }\n\n        lastChange.changes = text;\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        _repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true\n        /** repeatForInsert */\n        );\n\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {\n        keys: keys,\n        type: type\n      };\n      command[type] = name;\n      command[type + \"Args\"] = args;\n\n      for (var key in extra) {\n        command[key] = extra[key];\n      }\n\n      _mapCommand(command);\n    } // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n\n\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n\n        macroModeState.isPlaying = false;\n        return;\n      }\n\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n\n\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n\n      if (!macroModeState.isPlaying) {\n        while (changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n\n          if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined\n          /* only in testing */\n          ) {\n            var text = changeObj.text.join('\\n');\n\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              lastChange.changes.push(text);\n            }\n          } // Change objects may be chained with next.\n\n\n          changeObj = changeObj.next;\n        }\n      }\n    }\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n\n\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isPlaying) {\n          return;\n        }\n\n        var lastChange = macroModeState.lastInsertModeChanges;\n\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n\n      vim.fakeCursor = cm.markText(from, to, {\n        className: 'cm-animate-fat-cursor'\n      });\n    }\n\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head'); // Enter or exit visual mode to match mouse selection.\n\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\"\n        });\n      }\n\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n    /** Wrapper for special keys pressed in insert mode */\n\n\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n\n\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n\n      if (!keyName) {\n        return;\n      }\n\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n\n\n    function _repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n\n      vim.inputState = vim.lastEditInputState;\n\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n\n        repeatInsert(repeat);\n      }\n\n      vim.inputState = cachedInputState;\n\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n\n        return true;\n      }\n\n      var head = cm.getCursor('head');\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\n\n      if (inVisualBlock) {\n        // Set up block selection again for repeating the changes.\n        var vim = cm.state.vim;\n        var lastSel = vim.lastSelection;\n        var offset = getOffset(lastSel.anchor, lastSel.head);\n        selectForInsert(cm, head, offset.line + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n\n      for (var i = 0; i < repeat; i++) {\n        if (inVisualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  }; // Initialize Vim and make it available as an API.\n\n\n  CodeMirror.Vim = Vim();\n});"],"sourceRoot":""}