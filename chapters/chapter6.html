<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Chapter 6: Data Wrangling</title>

<script src="chapter6_files/header-attrs-2.11/header-attrs.js"></script>
<script src="chapter6_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="chapter6_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="chapter6_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="chapter6_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="chapter6_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="chapter6_files/navigation-1.1/tabsets.js"></script>
<link href="chapter6_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="chapter6_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div id="header">



<h1 class="title toc-ignore">Chapter 6: Data Wrangling</h1>

</div>


<p><exercise id="1" title="Introduction to tidyverse"></p>
<p>The tidyverse is a powerful collection of R packages that transform and visualize data. This chapter focuses on two packages <strong>tidyr</strong> and <strong>dplyr</strong>. <strong>tidyr</strong> helps you to create tidy data or data where each variable is in a column, each observation is a row and each value is a cell. <strong>dplyr</strong> is used for grammar of data manipulation. You can use it to solve the most common data manipulation challenges.</p>
<p>You can install the complete tidyverse with: <code>install.packages("tidyverse")</code></p>
<p>Then, to load the package:</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<pre><code>## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──</code></pre>
<pre><code>## ✓ ggplot2 3.3.5     ✓ purrr   0.3.4
## ✓ tibble  3.1.6     ✓ dplyr   1.0.7
## ✓ tidyr   1.1.4     ✓ stringr 1.4.0
## ✓ readr   2.1.1     ✓ forcats 0.5.1</code></pre>
<pre><code>## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()</code></pre>
<div id="tidy-reshape-your-data" class="section level2">
<h2>Tidy (reshape) your data</h2>
<p>Raw data that we acquired can often be messy and complicated. The tidyr package allows you to wrangle messy datasets into nice and tidy ones.</p>
<p>A tidy data format has a rectangular shape which means it has columns, rows, and cells, just like in a spreadsheet. Each column should hold a single variable, each row should hold a single observation and each cell should hold a single value.</p>
<p>The example below shows the same information (country, year, population, and number of cases) organised in 3 different ways. Examine each of the table.</p>
<pre class="r"><code>table1</code></pre>
<pre><code>## # A tibble: 6 × 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<pre class="r"><code>table2</code></pre>
<pre><code>## # A tibble: 12 × 4
##    country      year type            count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583</code></pre>
<pre class="r"><code>table3</code></pre>
<pre><code>## # A tibble: 6 × 3
##   country      year rate             
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583</code></pre>
<p>Which table is tidy? <choice> <opt text="Table 1 only" correct="true"></p>
<p>Good job!</p>
<p></opt></p>
<p><opt text="Table 3 only"></p>
<p>This is not a correct answer.</p>
<p></opt></p>
<p><opt text="Table 1 and 3"></p>
<p>This is not a correct answer.</p>
<p></opt></p>
<p><opt text="Table 2 and 3"></p>
<p>This is not a correct answer.</p>
<p></opt></p>
<p></choice></p>
<p>Sometimes raw data may have multiple variables or multiple values (not the same variable) in the same column, or sometimes you may want to merge multiple columns into one. Here are a few commands that can be helpful in manupulating the data into a tidy format:</p>
<ul>
<li><code>separate()</code>: separating multiple variables in one column to different columns</li>
<li><code>unite()</code>: merging multiple columns into one, inserting underscore <code>_</code> as a separator between the two inputs.</li>
<li><code>separate_rows()</code>: separating multiple observations in the same cell. We pass the messy column name and a string to use as a separator.</li>
</ul>
<p>In table 3, the <code>rate</code> column contains both the number of cases and the size of the populations. We want to separate the <code>rate</code> variable into variables <code>cases</code> and <code>population</code>.</p>
<pre class="r"><code>table3 %&gt;%
  separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;, convert = TRUE)</code></pre>
<pre><code>## # A tibble: 6 × 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<p>The <code>into</code> argument expects a vector of column names. The <code>sep</code> argument expects the non-alphanumeric character (a charater that is not a letter or a number) that we split upon. The <code>convert</code> argument is set to TRUE here so that R will try and convert to better types after the split.</p>
<p>In table 5, the <code>century</code> and <code>year</code> column can be combined to give a <code>year_new</code> column. The <code>sep</code> argument here is what comes in between the values from different columns. If we don’t want anything in between, we can use ““.</p>
<pre class="r"><code>table5 %&gt;%
  unite(new_year,century, year, sep = &quot;&quot;)</code></pre>
<pre><code>## # A tibble: 6 × 3
##   country     new_year rate             
##   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;            
## 1 Afghanistan 1999     745/19987071     
## 2 Afghanistan 2000     2666/20595360    
## 3 Brazil      1999     37737/172006362  
## 4 Brazil      2000     80488/174504898  
## 5 China       1999     212258/1272915272
## 6 China       2000     213766/1280428583</code></pre>
<p>In table 6, there are multiple observations in the same cell in each row of <code>year</code> and <code>cases</code>. We would like to separate them.</p>
<pre class="r"><code>table6 &lt;- tibble(
  country = c(&quot;Afghanistan&quot;, &quot;Brazil&quot;, &quot;China&quot;),
  year = c(&quot;1999,2000&quot;, &quot;1999,2000&quot;, &quot;1999,2000&quot;),
  cases= c(&quot;745,2666&quot;, &quot;37737,80488&quot;, &quot;212258,213766&quot;)
)

table6 %&gt;%
  separate_rows(cases, year, sep=&#39;,&#39;, convert = TRUE)</code></pre>
<pre><code>## # A tibble: 6 × 3
##   country      year  cases
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;
## 1 Afghanistan  1999    745
## 2 Afghanistan  2000   2666
## 3 Brazil       1999  37737
## 4 Brazil       2000  80488
## 5 China        1999 212258
## 6 China        2000 213766</code></pre>
</div>
<div id="missing-values" class="section level2">
<h2>Missing values</h2>
<p>There are various ways to handle missing values (the NAs) in your data set. Tidyr has three functions:</p>
<ul>
<li><code>fill()</code>: fill the missing values using the last observation carried forward. It has a <code>.direction</code> argument that you can pass <code>up</code> or <code>down</code>.</li>
<li><code>drop_na()</code>: drop the rows with observations that are <code>NA</code></li>
<li><code>replace_na()</code>: replace the <code>NA</code> with specific values</li>
</ul>
<p>Let’s look at this toy data set. We will start with the <code>fill()</code> function to impute the <code>return</code> column in the <code>up</code> direction, then we will impute in the <code>down</code> direction. Can you spot the difference?</p>
<pre class="r"><code>apple &lt;- tibble(
  year   = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr    = c(   1,    2,    3,    4,    2,    3,    4),
  return = c(0.75, 0.39, 0.34,   NA, 0.99, 0.07, 1.88)
)

apple %&gt;%
  fill(return, .direction = &quot;up&quot;)</code></pre>
<pre><code>## # A tibble: 7 × 3
##    year   qtr return
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1  2020     1   0.75
## 2  2020     2   0.39
## 3  2020     3   0.34
## 4  2020     4   0.99
## 5  2021     2   0.99
## 6  2021     3   0.07
## 7  2021     4   1.88</code></pre>
<pre class="r"><code>apple %&gt;%
  fill(return, .direction = &quot;down&quot;)</code></pre>
<pre><code>## # A tibble: 7 × 3
##    year   qtr return
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1  2020     1   0.75
## 2  2020     2   0.39
## 3  2020     3   0.34
## 4  2020     4   0.34
## 5  2021     2   0.99
## 6  2021     3   0.07
## 7  2021     4   1.88</code></pre>
<p>Then, we will try to drop the NAs in the return in <code>apple</code>.</p>
<pre class="r"><code>apple %&gt;%
  drop_na(return)</code></pre>
<pre><code>## # A tibble: 6 × 3
##    year   qtr return
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1  2020     1   0.75
## 2  2020     2   0.39
## 3  2020     3   0.34
## 4  2021     2   0.99
## 5  2021     3   0.07
## 6  2021     4   1.88</code></pre>
<p>Finally, we will also replace the NAs with the value <code>999</code>.</p>
<pre class="r"><code>apple %&gt;%
  replace_na(list(return=999))</code></pre>
<pre><code>## # A tibble: 7 × 3
##    year   qtr return
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1  2020     1   0.75
## 2  2020     2   0.39
## 3  2020     3   0.34
## 4  2020     4 999   
## 5  2021     2   0.99
## 6  2021     3   0.07
## 7  2021     4   1.88</code></pre>
</div>
<div id="pivoting" class="section level2">
<h2>Pivoting</h2>
<p>Two common problems in raw data set: - some of the column names are not really names of variables, but <strong>values</strong> of a variable. - when an observation is scattered across multiple rows.</p>
<p>To tackle these problems, you will need <code>pivot_longer()</code> and/or <code>pivot_wider()</code></p>
<p><strong>pivot_longer()</strong></p>
<p><code>table4a</code> is a great example of data that needs <code>pivot_longer()</code>. Here you see that the case count of each country is separated into two columns because they are from different years.</p>
<pre class="r"><code>table4a</code></pre>
<pre><code>## # A tibble: 3 × 3
##   country     `1999` `2000`
## * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766</code></pre>
<p>The first argument is the vector of column names that are actually values not variables. The second argument is the name of the variable to move the column <strong>names</strong> to. The third argument is the name of the variable to move the column <strong>values</strong> to.</p>
<pre class="r"><code>table4a %&gt;% 
  pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;cases&quot;)</code></pre>
<pre><code>## # A tibble: 6 × 3
##   country     year   cases
##   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;
## 1 Afghanistan 1999     745
## 2 Afghanistan 2000    2666
## 3 Brazil      1999   37737
## 4 Brazil      2000   80488
## 5 China       1999  212258
## 6 China       2000  213766</code></pre>
<p><strong>pivot_wider()</strong></p>
<p>In table 2, each observation is a certain country in a certain year. However, the observation is spread across two rows since there are <code>cases</code> and <code>population</code>.</p>
<pre class="r"><code>table2</code></pre>
<pre><code>## # A tibble: 12 × 4
##    country      year type            count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583</code></pre>
<p>The first argument is the column to take variable <strong>names</strong> from, which is <code>type</code>. The second argument is the column to take variable <strong>values</strong> from, where is <code>count</code>.</p>
<pre class="r"><code>table2 %&gt;%
  pivot_wider(names_from = type, values_from = count)</code></pre>
<pre><code>## # A tibble: 6 × 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<p></exercise></p>
<p><exercise id="2" title="Introduction to dplyr"> <code>dplyr</code> provides a selection of tools for the most common data wrangling tasks.</p>
</div>
<div id="data-transformation-and-aggregation" class="section level2">
<h2>Data Transformation and Aggregation</h2>
<p>There are a bunch of useful commands to transform and aggregate data in R.</p>
<ul>
<li><code>select()</code>: pick particular variables from your data.</li>
</ul>
<pre class="r"><code>table1 %&gt;%
  select(country)</code></pre>
<pre><code>## # A tibble: 6 × 1
##   country    
##   &lt;chr&gt;      
## 1 Afghanistan
## 2 Afghanistan
## 3 Brazil     
## 4 Brazil     
## 5 China      
## 6 China</code></pre>
<ul>
<li><code>filter()</code>: extract observations from the data based on a given condition</li>
</ul>
<pre class="r"><code>table2 %&gt;%
  filter(year==1999)</code></pre>
<pre><code>## # A tibble: 6 × 4
##   country      year type            count
##   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
## 1 Afghanistan  1999 cases             745
## 2 Afghanistan  1999 population   19987071
## 3 Brazil       1999 cases           37737
## 4 Brazil       1999 population  172006362
## 5 China        1999 cases          212258
## 6 China        1999 population 1272915272</code></pre>
<ul>
<li><code>arrange()</code>: sort your data based on one or more variables</li>
</ul>
<pre class="r"><code>table2 %&gt;%
  arrange(count)</code></pre>
<pre><code>## # A tibble: 12 × 4
##    country      year type            count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  2000 cases            2666
##  3 Brazil       1999 cases           37737
##  4 Brazil       2000 cases           80488
##  5 China        1999 cases          212258
##  6 China        2000 cases          213766
##  7 Afghanistan  1999 population   19987071
##  8 Afghanistan  2000 population   20595360
##  9 Brazil       1999 population  172006362
## 10 Brazil       2000 population  174504898
## 11 China        1999 population 1272915272
## 12 China        2000 population 1280428583</code></pre>
<ul>
<li><code>mutate()</code>: add new variables or change existing variables</li>
</ul>
<pre class="r"><code>table1 %&gt;%
  mutate(rate = cases/population)</code></pre>
<pre><code>## # A tibble: 6 × 5
##   country      year  cases population      rate
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;     &lt;dbl&gt;
## 1 Afghanistan  1999    745   19987071 0.0000373
## 2 Afghanistan  2000   2666   20595360 0.000129 
## 3 Brazil       1999  37737  172006362 0.000219 
## 4 Brazil       2000  80488  174504898 0.000461 
## 5 China        1999 212258 1272915272 0.000167 
## 6 China        2000 213766 1280428583 0.000167</code></pre>
<ul>
<li><code>group_by()</code> and <code>ungroup()</code>: takes existing data and groups specific variables together for future operations. These two functions are often used together with other <code>dplyr</code> functions. We will introduce them with the <code>summarize()</code> function. The <code>summarize()</code> function creates a new dataframe based on the argument provided.</li>
</ul>
<pre class="r"><code>table2 %&gt;% group_by(type) %&gt;% summarize(min = min(count), max =max(count))</code></pre>
<pre><code>## # A tibble: 2 × 3
##   type            min        max
##   &lt;chr&gt;         &lt;int&gt;      &lt;int&gt;
## 1 cases           745     213766
## 2 population 19987071 1280428583</code></pre>
<p>You can summarize the data in different ways based on the groupings and different argument you included.</p>
<pre class="r"><code>table2 %&gt;% group_by(type) %&gt;% summarize(mean(count), median(count),sd(count))</code></pre>
<pre><code>## # A tibble: 2 × 4
##   type       `mean(count)` `median(count)` `sd(count)`
##   &lt;chr&gt;              &lt;dbl&gt;           &lt;dbl&gt;       &lt;dbl&gt;
## 1 cases             91277.          59112.      98662.
## 2 population    490072924.      173255630   613130267.</code></pre>
<ul>
<li><code>count()</code>: a convenient way to get a sense of the distribution of values in a data set.</li>
</ul>
<pre class="r"><code>table2 %&gt;% count(country)</code></pre>
<pre><code>## # A tibble: 3 × 2
##   country         n
##   &lt;chr&gt;       &lt;int&gt;
## 1 Afghanistan     4
## 2 Brazil          4
## 3 China           4</code></pre>
</div>
<div id="joining-datasets" class="section level2">
<h2>Joining Datasets</h2>
<p>Often you will need information from multiple datasets in your data analysis. It is important to learn different types of joins to accommodate different needs in your tasks.</p>
<p>We are going to use the following tables in our example. Consider there are 4 students in a class and they submitted homework 1 and homework 2. The tables contains their scores for the homeworks (gradebook) and not everyone submitted their homework during the semester.</p>
<pre class="r"><code>homework1 &lt;- tibble(name = c(&#39;Alphonso&#39;, &#39;Daisy&#39;, &#39;Philip&#39;), student_no = c(456,100,102), marks = c(80, 65, 34))
homework2 &lt;- tibble(name = c(&#39;Alphonso&#39;, &#39;Philip&#39;, &#39;Melinda&#39;), student_no = c(456,102,432), marks = c(85, 97, 56))</code></pre>
<div id="mutating-joins" class="section level3">
<h3>Mutating Joins</h3>
<p>Mutation joins return a copy of the dataset that has been augmented.</p>
<p><strong>Inner Join</strong></p>
<p>Inner joins retain only rows that exists on both datasets.</p>
<pre class="r"><code>inner_join(homework1, homework2, by = c(&#39;name&#39;,&#39;student_no&#39;))</code></pre>
<pre><code>## # A tibble: 2 × 4
##   name     student_no marks.x marks.y
##   &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
## 1 Alphonso        456      80      85
## 2 Philip          102      34      97</code></pre>
<p>When we perform inner join by <code>name</code> and <code>student_no</code>, R only returns rows that exists in both data set. When we do inner join with our <code>homework1</code> and <code>homework2</code> gradebooks, only <code>Alphonso</code> and <code>Philip</code> ’s marks will show up since they are the only ones that submitted both homeworks.</p>
<p><strong>Left Join</strong></p>
<p>Left joins starts with the left data set (<code>homework1</code>) and search in the right data set looking for the same values of <code>name</code> and <code>student_no</code> to add to the left data set.</p>
<pre class="r"><code>left_join(homework1, homework2, by = c(&#39;name&#39;,&#39;student_no&#39;))</code></pre>
<pre><code>## # A tibble: 3 × 4
##   name     student_no marks.x marks.y
##   &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
## 1 Alphonso        456      80      85
## 2 Daisy           100      65      NA
## 3 Philip          102      34      97</code></pre>
<p>When we do left join with our <code>homework1</code> and <code>homework2</code> gradebooks, we will only consider those students who submitted homework 1 and look for their marks in homework 2. Melinda’s result will not be included in the join even though she has submitted her homework 2, while Daisy will have <code>NA</code> showing as the missing value.</p>
<p><strong>Right Join</strong></p>
<p>Right joins starts with the right data set (homework2) and search in the left data set looking for the same values of <code>name</code> and <code>student_no</code> to add to the right data set.</p>
<pre class="r"><code>right_join(homework1, homework2, by = c(&#39;name&#39;,&#39;student_no&#39;))</code></pre>
<pre><code>## # A tibble: 3 × 4
##   name     student_no marks.x marks.y
##   &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
## 1 Alphonso        456      80      85
## 2 Philip          102      34      97
## 3 Melinda         432      NA      56</code></pre>
<p>When we do right join with our <code>homework1</code> and <code>homework2</code> gradebooks, we will only consider those students who submitted homework 2 and look for their marks in homework 1. Daisy’s result will not be included in the join even though she has submitted her homework 1, while Melinda will have <code>NA</code> showing as the missing value.</p>
<p><strong>Full Join</strong> Full joins retain all rows.</p>
<pre class="r"><code>full_join(homework1, homework2, by = c(&#39;name&#39;,&#39;student_no&#39;))</code></pre>
<pre><code>## # A tibble: 4 × 4
##   name     student_no marks.x marks.y
##   &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
## 1 Alphonso        456      80      85
## 2 Daisy           100      65      NA
## 3 Philip          102      34      97
## 4 Melinda         432      NA      56</code></pre>
<p>All the submissions with the corresponding mark are included in the full join of the gradebook.</p>
</div>
<div id="filtering-joins" class="section level3">
<h3>Filtering Joins</h3>
<p>Filtering joins return a copy of the dataset that has been filtered.</p>
<p><strong>Semi Join</strong> The semi join returns a filtered version of the left data set based on matching entries in the right data set.</p>
<pre class="r"><code>semi_join(homework1, homework2, by = c(&#39;name&#39;,&#39;student_no&#39;))</code></pre>
<pre><code>## # A tibble: 2 × 3
##   name     student_no marks
##   &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;
## 1 Alphonso        456    80
## 2 Philip          102    34</code></pre>
<pre class="r"><code>semi_join(homework2, homework1, by = c(&#39;name&#39;,&#39;student_no&#39;))</code></pre>
<pre><code>## # A tibble: 2 × 3
##   name     student_no marks
##   &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;
## 1 Alphonso        456    85
## 2 Philip          102    97</code></pre>
<p><strong>Anti Join</strong> Now, let’s say we want to know who didn’t submit homeworks. The anti join will return the rows in the left data set that doesn’t have an entry in the right data set.</p>
<pre class="r"><code>anti_join(homework1, homework2, by = c(&#39;name&#39;,&#39;student_no&#39;))</code></pre>
<pre><code>## # A tibble: 1 × 3
##   name  student_no marks
##   &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;
## 1 Daisy        100    65</code></pre>
<pre class="r"><code>anti_join(homework2, homework1, by = c(&#39;name&#39;,&#39;student_no&#39;))</code></pre>
<pre><code>## # A tibble: 1 × 3
##   name    student_no marks
##   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;
## 1 Melinda        432    56</code></pre>
<p></exercise></p>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
